\chapter{Implementacja systemu}\indent \par

W tym rozdziale opisana zosta³a implementacja wybranych elementów zaprojektowanego systemu.


\section{Aplikacja serwerowa}\indent \par

\subsection{Wykorzystywane technologie i narzêdzia}\indent \par 

Podczas realizacji systemu wykorzystano nastêpuj¹ce technologie: 

\begin{enumerate}
	\item Java 1.8
	\item Spring Framework\ref{tech:spring} - jest to szkielet tworzenia aplikacji internetowych w jêzyku Javy dla platformy Enterprise Edition. Obecnie jest jedn¹ z najbardziej popularnych technologii na rynku ze wzglêdu na wsparcie twórców i spo³ecznoœci oraz du¿e mo¿liwoœci konfiguracyjne, po pozwala ³atwo dostosowaæ go do w³asnych potrzeb
	\item Spring Boot - rozszerzenie framworka Spring pozwalaj¹ce na uruchomienie aplikacji jak wykonywalnego programu Javy
	\item Spring Security - rozszerzenie skupiaj¹ce siê na dostarczeniu funkcjonalnoœci autentykowania i autoryzacji u¿ytkowników w aplikacjach Spring
	\item Hibernate - narzêdzie do realizacji warstwy dostêpu do danych, pozwala na przenoszenie danych pomiêdzy relacyjn¹ baz¹ danych a obiektami Javy 
	\item Swagger UI - narzêdzie generuj¹ce dokumentacjê API dostêpn¹ pod wybranym adresem URL wewn¹trz aplikacji internetowej
	\item JSON Web Token - metoda reprezentowania deklaracji uprawnie¿ u¿ytkowników pozwalaj¹ca na bezpieczne przesy³anie informacji pomiêdzy dwoma stronami
	\item Maven
	\item projekt Cerberus - w ramach tego projektu zaprezentowano implementacjê systemu bezstanowej autoryzacji u¿ytkowników z wykorzystaniem Spring Security oraz JSON Web Token.
\end{enumerate}
\subsection{Struktura plików projektu}

Projekt zosta³ wykonany w œrodowisku Intellij IDEA w wersji 2016.2 Ultimate. 
Pliki klas projektu podzielone zosta³y na paczki zgodnie z ich zastosowaniem: 

\begin{itemize}
	\item config - zawiera pliki konfiguracyjne frameworka Spring, oznaczone adnotacj¹ \texttt{@Configuration}
	\item constant - zawiera klasy definiuj¹ce sta³e u¿ywane w projekcie
	\item controller - zawiera klasy kontrolerów, które obs³uguj¹ zapytania http wysy³ane na przypisane im adresy URL i poprzez klasy service zwracaj¹ u¿ytkownikowi dane z bazy danych
	\item mapper - zawiera klasy pozwalaj¹ce na konwersje pomiêdzy klasami modelu
	\item model - zawiera definicje obiektów reprezentuj¹cych rzeczywiste dane, na których operuje system
	\item repository - zawiera interfejsy dostêpu do bazy danych (ang. DAO - database access object), w których zdefiniowane s¹ zapytania wywo³ywane przez aplikacje
	\item security - pochodz¹ce z projektu Cerberus klasy wspomagaj¹ce obs³ugê autoryzacji przy pomocy tokena
	\item service - zawiera klasy przetwarzaj¹ce dane pobrane z bazy danych przez DAO przed przekazaniem ich do kontrolera
	\item task - zawiera klasy automatyzuj¹ce zadania wykonywane przez aplikacje poprzez okresowe wywo³ywanie metod
\end{itemize}

Oprócz plików z kodem Ÿród³owym programu wa¿nym plikiem jest \texttt{pom.xml} pozwalaj¹cy na do³¹czanie do projektu zewnêtrznych bibliotek pobieranych z odpowiednich serwisów, np. Maven Repository\ref{tech:maven_repo}.

		\subsection{Zabezpieczenie dostêpu do API}\indent \par \label{zabezpieczenia}
Jako podstawê implementacji serwera wykorzystano projekt demonstracyjny Cerberus\ref{tech:cerberus} dostêpny na repozytorium GitHub na licencji MIT\ref{tech:mit}.  Konfiguracjê zabezpieczeñ tworzy siê poprzez utworzenie klasy rozszerzaj¹cej \texttt{WebSecurityConfigurerAdapter}. W tej klasie nadpisuje siê metodê \texttt{configure()}, a w niej tworzy politykê zabezpieczeñ dostêpu do API. Na listingu widocznym poni¿ej przedstawiono fragment konfiguracji, która okreœla trzy poziomy dostêpu dla ró¿nych adresów URL w zaleznoœci od zadeklarowanej grupy u¿ytkownika: 

\begin{enumerate}
	\item \texttt{USER}
\end{enumerate}

Nad deklaracj¹ klasy widnieje adnotacja \texttt{@Configuration} wskazuj¹ca na to, ¿e metody klasy mog¹ byæ wykorzystane przez Spring do tworzenia obiektów podczas uruchomienia programu.

\lstset{style=java}


\begin{lstlisting}[caption=Konfiguracja Spring Security]

$$@Configuration
$$@EnableWebSecurity
$$@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    $$@Override
    protected void configure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                .csrf()
                .disable()
                .exceptionHandling()
                .authenticationEntryPoint(this.unauthorizedHandler)
                .and()
                .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                .antMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                .antMatchers("/api/**").hasRole("USER")
                .antMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().permitAll();

        // Custom JWT based authentication
        httpSecurity
                .addFilterBefore(authenticationTokenFilterBean(), 
				UsernamePasswordAuthenticationFilter.class);
    }
\end{lstlisting}

W celu uaktywnienia filtrowania zapytañ, przed ka¿dym zapytaniem wywo³ywany jest filtr sprawdzaj¹cy obecnoœæ tokena w nag³ówku \texttt{X-Auth-Token} zapytania. Z uzyskanego tokena odczytywane s¹ dane u¿ytkownika, które nastêpnie przekazywane s¹ do filtra autoryzuj¹cego zapytania. W przypadku braku obecnoœci poprawnego tokena u¿ytkownik zostanie przekierowany na adres \texttt{/error/}.

\begin{lstlisting} 

public class AuthenticationTokenFilter 
	extends UsernamePasswordAuthenticationFilter {

  %%@Value(%%"X-Auth-Token"%%)%%
  private String tokenHeader;

  $$@Autowired
  private TokenUtils tokenUtils;

  $$@Autowired
  private UserDetailsService userDetailsService;

  $$@Override
  public void doFilter(ServletRequest request, ServletResponse response,
	 FilterChain chain) throws IOException, ServletException {

    HttpServletRequest httpRequest = (HttpServletRequest) request;
    String authToken = httpRequest.getHeader(this.tokenHeader);
    String username = this.tokenUtils.getUsernameFromToken(authToken);

    if (username != null && SecurityContextHolder
		.getContext().getAuthentication() == null) {
      UserDetails userDetails = this.userDetailsService
			.loadUserByUsername(username);
      if (this.tokenUtils.validateToken(authToken, userDetails)) {
        UsernamePasswordAuthenticationToken authentication = 
	new UsernamePasswordAuthenticationToken(userDetails, null,
				           userDetails.getAuthorities());
        authentication.setDetails(new WebAuthenticationDetailsSource()
				.buildDetails(httpRequest));
        SecurityContextHolder.getContext()
				.setAuthentication(authentication);
      }
    }

    chain.doFilter(request, response);
  }

}
\end{lstlisting}

		
\subsection{Baza danych} \indent \par \label{db}
Jako technologiê wykonania bazy danych wybrano Postgre SQL. Po³¹czenie z baz¹ danych realizowane jest przy pomocy sterownika JDBC. Parametry po³¹czenia i konfiguracja bazy danych okreœla klasa \texttt{DatabaseConfig} przedstawiona na listingu \ref{lst:db_config}. W konfiguracji definiowane jest obiekt \texttt{dataSource}, w którym zawarty jest adres bazy danych oraz dane logowania, a tak¿e dodatkowe ustawienia powi¹zane z frameworkiem Hibernate, w szczególnoœci okreœlana jest platforma bazy danych. W konfiguracji obiektu \texttt{EntityManagerFactory} odpowiedzialnego za tworzenie po³¹czeñ z baz¹ danych przekazywane s¹ ustalone wczeœniej parametry po³¹czenia, a tak¿e okreœlana jest œcie¿ka do modelu danych.
\begin{lstlisting}[label=lst:db_config,caption=Konfiguracja bazy danych]

$$@Configuration
$$@EnableTransactionManagement
%%@EnableJpaRepositories(%%"adamzimny.repository"%%)%%
public class DatabaseConfig {

    $$@Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("org.postgresql.Driver");
        dataSource.setUrl(
		"jdbc:postgresql://<database-url>");
        dataSource.setUsername("xxx");
        dataSource.setPassword("xxx");
        return dataSource;
    }

    $$@Bean
    public Properties jpaProperites() {
        Properties properties = new Properties();
        properties.setProperty("hibernate.hbm2ddl.auto", "update");
        properties.setProperty("hibernate.enable_lazy_load_no_trans", "true");
        return properties;
    }

    $$@Bean
    public HibernateJpaVendorAdapter jpaVendorAdapter() {
        HibernateJpaVendorAdapter hibernateJpaVendorAdapter
		= new HibernateJpaVendorAdapter();
        hibernateJpaVendorAdapter.setShowSql(false);
        hibernateJpaVendorAdapter
	.setDatabasePlatform("org.hibernate.dialect.PostgreSQLDialect");
        return hibernateJpaVendorAdapter;
    }

    $$@Bean
    public EntityManagerFactory entityManagerFactory() {
        HibernateJpaVendorAdapter vendorAdapter 
		= new HibernateJpaVendorAdapter();
        vendorAdapter.setGenerateDdl(true);

        LocalContainerEntityManagerFactoryBean factory 
		= new LocalContainerEntityManagerFactoryBean();
        factory.setJpaVendorAdapter(vendorAdapter);
        factory.setPackagesToScan("adamzimny.model");
        factory.setJpaVendorAdapter(jpaVendorAdapter());
        factory.setDataSource(dataSource());
        factory.setJpaProperties(jpaProperites());
        factory.afterPropertiesSet();
        return factory.getObject();
    }

    $$@Bean
    public PlatformTransactionManager transactionManager() {
        JpaTransactionManager txManager = new JpaTransactionManager();
        txManager.setEntityManagerFactory(entityManagerFactory());
        return txManager;
    }
}

\end{lstlisting}

Model fizyczny bazy danych generowany jest na podstawie klas znajduj¹cych siê w pakiecie \texttt{model}. Podczas uruchomienia aplikacji baza danych obecna na serwerze jest skanowana pod k¹tem ró¿nic z modelem. Je¿eli zostan¹ one wykryte, wykonywane s¹ modyfikacje prowadz¹ce do przeniesienia zmian z modelu na bazê danych. Du¿¹ zalet¹ tego rozwi¹zania jest brak koniecznoœci prowadzania rêcznych modyfikacji w bazie danych.

Tworzenie tabel w bazie danych zarz¹dzane jest przez dodanie odpowiednich adnotacji w klasach modelu. Przyk³adowa klasa przedstawiona zosta³a na listingu \ref{lst:model}. Adnotacja \texttt{@Entity} mówi o tym, ¿e nale¿y utworzyæ z tej klasy tabelê w bazie danych. Pole adnotowane \texttt{@Id} staje siê kluczem  g³ównym tabeli, którego wartoœci bêd¹ generowane automatycznie dziêki adnotacji \texttt{@GeneratedValue}. Klucze obce tabeli oznaczane s¹ jedn¹ z adnotacji \texttt{@OneToOne, @OneToMany, @ManyToOne, @ManyToMany}, zale¿nie od typu relacji pomiêdzy encjami.

\begin{lstlisting}[label={lst:model}, caption={Przyk³adowa klasa modelu}]
$$@Entity
public class Target {

    $$@Id
    %%@GeneratedValue(%%strategy= GenerationType.AUTO%%)%%
    Integer id;
    $$@OneToOne
    User hunted;
    $$@OneToOne
    User hunter;
    String status;

    %%@JsonFormat(pattern=%%"yyyy-MM-dd HH:mm:ss Z"%% )%%
    Date created;

    %%@JsonFormat(pattern=%%"yyyy-MM-dd HH:mm:ss Z"%%)%%
    Date completed;
    boolean publicTarget = false;

    $$@OneToOne
    Location location;
}
\end{lstlisting}

Interfejsy dostêpu do bazy danych znajduj¹ce siê w pakiecie \texttt{repository} rozszerzaj¹ klasê \texttt{JpaRepository}. Klasa ta dostarcza podstawowych metod operacji na tabelach, takich jak \texttt{save()} czy \texttt{findAll()}. Tworzenie dodatkowych zapytañ jest mo¿liwe poprzed deklaracje metod interfejsu. Nie ma koniecznoœci pisania zapytañ w jêzyku SQL, framework Hibernate dostarcza mechanizm pozwalaj¹cy na generowanie ich na podstawie nazwy metody. Nazwa powinna rozpoczynaæ siê od s³ów \texttt{findBy}, po których znajduj¹ siê nazwy kolumn w tabeli. Mo¿liwe jest równie¿ grupowanie, zliczanie i sortowanie wyników wed³ug tej samej konwencji nazewnictwa


\begin{lstlisting}[label={lst:repo},caption={Przyk³adowy interfejs DAO}]
$$@Repository
$$@Transactional
public interface LocationDAO extends JpaRepository<Location,Integer> {

    List<Location> findByUserAndDateAfter(User user, Date date);
    List<Location> findByUserAndType(User user, String type);
    List<Location> findByUser(User user);
    List<Location> findByUserOrderByDateDesc(User user);
}
\end{lstlisting}

Mechanizm tworzenia zapytañ jest jednak ograniczony do jednej tabeli. Je¿eli zapytanie wymaga po³¹czenia rekordów wielu tabel, wymagane jest u¿ycie adnotacj \texttt{@Query} nad metod¹ interfejsu oraz podanie w niej pe³nego zapytania w sk³adni SQL. Parametry zapytania nale¿y opisaæ adnotacj¹ \texttt{@Param}.


\begin{lstlisting}[label={lst:query}, caption={Zapytanie SQL zawieraj¹ce ³¹czenie tabel}]

    %%@Query(%%"select u from Target t join t.hunter u group
		by u.id having count(t) < :count"%%)%%
    List<User> findByTargetCountLessThan(%%@Param(%%"count"%%) %%long count);
		
\end{lstlisting}


\subsection{Komunikacja i przep³yw danych} \indent \par

Komunikacja pomiêdzy serwerem a aplikacjami mobilnymi realizowana jest przy pomocy zapytañ HTTP. Po poprawnym przetworzeniu zapytania wys³anego przez aplikacjê klienck¹, serwer odpowiada danymi zapisywanymi w formacie JSON.

Aplikacje tworzone przy pomocy frameworka spring cechuj¹ siê wspóln¹ architektur¹ warstwow¹ definiuj¹c¹ przep³yw informacji w systemie. Po otrzymaniu zapytania HTTP przez aplikacjê przekazywane jest ono do odpowiedniego kontrolera. Adresy obs³ugiwane przez kontroler lub jego metody okreœla siê przy pomocy adnotacji \texttt{@RequestMapping}, co pokazane na listingu \ref{lst:controller}. 

\begin{lstlisting}[label=lst:controller, caption=Przyk³adowy kontroler]
$$@EnableAutoConfiguration
$$@RestController
public class UserController {

    $$@Autowired
    UserService userService;
		
    %%@RequestMapping(value = %%"api/user/status"%%, method = %%RequestMethod.PATCH%%)%%
    public ResponseEntity<?> changeStatus(%%@RequestParam(%%"user"%%)%% long id,  
		%%@RequestParam(%%"status"%%)%% String status) {
        if ("active".equals(status) || "suspended".equals(status)) {
            Optional<User> userOptional = userService.get(id);
            if (userOptional.isPresent()) {
                User user = userOptional.get();
                user.setStatus(status);
                userService.save(user);
                return ResponseEntity.ok(userOptional.get());
            }
        }
        return ResponseEntity.badRequest().body(null);
    }
}
\end{lstlisting}

Po otrzymaniu zapytania kontroler mo¿e wywo³aæ metody klas typu \texttt{service}, które z kolei pobieraj¹ dane z bazy danych poprzez metody klas typu DAO z pakietu \texttt{repository}.

\begin{lstlisting}[label={lst:service},caption={Przyk³adowy serwis aplikacji}]
$$@Service
public class UserService {
    $$@Autowired
    UserDAO userDAO;

    public Optional<User> get(long id) {
        return userDAO.findById(id);
    }
}

\end{lstlisting}

Po zwróceniu danych z bazy w kontrolerze tworzona jest odpowiedŸ na zapytanie. Zale¿nie od przebiegu obs³ugi zapytania, ustawiany jest status odpowiedzi, a w przypadku zapytañ poprawnych (ze statusem \texttt{200 Ok}) w cia³o odpowiedzi wpisywane s¹ pobrane z bazy danych wyniki.

\subsection{Implementacja obs³ugi wybranych zapytañ}

Obs³uga zapytañ przez serwer jest w wielu przypadkach bardzo zbli¿ona. W tym dziale przedstawione zosta³y przyk³adowe realizacje wybranych wymagañ funkcjonalnych. 

\subsubsection{Rejestracja}\indent \par

Tworzenie nowych obiektów w konwencji REST realizwane jest przez zapytania typu \texttt{POST}. Rejestracja nowego konta u¿ytkownika rozpoczyna siê od przes³ania zapytania  na adres \texttt{/register/}. Zapytania wysy³ane na ten adres nale¿¹ do trzeciej grupy opisanej w punkcie \ref{prot_kom} i nie musz¹ posiadaæ tokena.

\begin{lstlisting}[label={lst:register_controller},caption={Kontroler rejestracji}]

$$@RestController
public class RegisterController {

    $$@Autowired
    UserService userService;

    %%@RequestMapping(value = %%"register"%%, method = %%RequestMethod.POST%%)%%
    public ResponseEntity<?> register(%%@RequestBody%% UserTemplate userTemplate) {
        User user = UserMapper.map(userTemplate);
        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        User u = userService.register(user);
        return ResponseEntity.ok().body(u);
    }
}

\end{lstlisting}

W kontrolerze pobierany jest przes³any parametr \texttt{userTemplate}. Przy wykorzystaniu klasy konweruj¹cej z pakietu \texttt{mapper} tworzony jest obiekt klasy \texttt{User}, która jest docelow¹ klas¹ zapisywan¹ w bazie danych.

Has³o przes³ane przez u¿ytkownika jest szyfrowane, aby nie zosta³o zapisane jawnym tekstem w bazie danych. Po zaszyfrowaniu has³a obiekt przekazywany jest do serwisu. 

\begin{lstlisting}[label={lst:user_service},caption={Metoda rejestracji u¿ytkownika w klasie \texttt{UserService}}]

    public User register(User user) {
        user.setRegisterDate(new Date());
        user.setStatus("ACTIVE");
        user.setAuthorities("ROLE_USER");

        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
        Date d;
        try {
            d = sdf.parse("01/01/1980");
        } catch (ParseException e) {
            d = new Date();
        }
        user.setNoTargetSince(d);

        userDAO.save(user);
        return user;
    }
		
\end{lstlisting}

Serwis zajmuje siê przygotowaniem obiektu do zapisu w bazie danych. Ustawiana jest data rejestracji i nadawane s¹ uprawnienia u¿ytkownika. Dodatkowo u¿ytkownikowi przypisuje siê datê, od której nie posiada on zleceñ jako rok 1980. Pozwoli to odnaleŸæ nowych u¿ytkowników w systemie sortuj¹c po dacie i nadaæ im priorytet w przydzielaniu zleceñ.

Po wykonaniu tych operacji obiekt jest zapisywany w bazie danych metod¹ \texttt{save()} klasy \texttt{UserDAO} i zwracany do kontrolera. W kontrolerze tworzona jest odpowiedŸ na zapytanie o statusie \texttt{200 Ok} informuj¹cym o poprawnym wykonaniu rejestracji, a nowo utworzony obiekt u¿ytkownika jest zwracany jako w odpowiedzi.

\subsubsection{Pobranie lokalizacji u¿ytkownika}\indent \par

Jako zapytania zwracaj¹ce dane uzytkownikowi przyj¹to zapytania \texttt{GET}. Parametrami zapytania s¹ id uzytkownika oraz data, od której nale¿y wyszukaæ lokalizacje. W sygnaturze metody przed drugim parametrem znajduje siê dopisek \texttt{required = false}. Oznacza to, ¿e parametr ten jest opcjonalny, czyli zapytanie wys³ane na adres \texttt{/api/location?user=1} równie¿ zostanie obs³u¿one przez tê metodê.

Rozpoczynaj¹c obs³ugê zapytania kontroler wyszukuje u¿ytkownika o zadanym numerze id w bazie danych. Je¿eli u¿ytkownik nie zostanie znaleziony, tworzona jest odpowiedŸ o statusie \texttt{400 Bad request}. W przypadku znalezienia u¿ytkownika, sprawdzana jest obecnoœæ opcjonalnego parametru daty i je¿eli zosta³ on podany, uwzglêdniany jest on w dalszej obs³udze zapytania przez serwis. 

\begin{lstlisting}[label={lst:location_controller},caption={Kontroler lokalizacji u¿ytkownika}]
%%@RequestMapping(value = %%"api/location"%%)%%
public class LocationController {

%%@RequestMapping(value = %%"api/location"%%, method = %%RequestMethod.GET%%)%%
    public ResponseEntity<?> findByUserAndDateAfter(
            %%@RequestParam(%%"user"%%)%% long id,
            %%@RequestParam(value = %%"date"%%, %%
			%%required =%% false%%)%% String dateString)
            throws ParseException {

        Optional<User> user = userService.get(id);
        if (user.isPresent()) {
            if (dateString != null) {
                DateFormat df = new SimpleDateFormat(
				        "yyyy-MM-dd HH:mm:ss zzz");
                Date date = df.parse(dateString);

                return ResponseEntity.ok(locationService
	    			.findByUserAndDateAfter(user.get(), date));
            } else {
                return ResponseEntity.ok(locationService
		    		.findByUser(user.get()));
            }
        }
        return ResponseEntity.badRequest().body("User not found!");
    }
}
\end{lstlisting}

Kontroler wywo³uje jedn¹ z dwóch metod serwisu zale¿nie od wartoœci parametru \texttt{date}. W obs³udze tego zapytania nie ma ¿adnej dodatkowej logiki, która musi zostaæ wykonana przez serwis, wiêc jego dzia³anie sprowadza siê do pobrania rekordów z bazy danych i ich zwrócenia.

 

\begin{lstlisting}[label={lst:location_service},caption={Metody pobierania lokalizacji w \texttt{LocationService}}]

    public List<Location> findByUserAndDateAfter(User user, Date date) {
        List<Location> list = locationDAO.findByUserAndDateAfter(user, date);
        return list;
    }
		
		    public List<Location> findByUser(User user) {
        return locationDAO.findByUser(user);
    }
	}

\end{lstlisting}

Po wykonaniu opracji na bazie danych tworzona jest odpowiedŸ na zapytanie o statusie \texttt{200 Ok}.

\subsubsection{Potwierdzenie wykonania zlecenia}\indent \par

Do wprowadzania modyfikacji u¿ywa siê metody \texttt{PATCH} zapytañ HTTP. Parametrami zapytania s¹ numer id zlecenia oraz kod potwierdzaj¹cy. Po otrzymaniu zapytania na adres \texttt{/api/target/confirm} kontroler wyszukuje zlecenie o zadanym numerze. Je¿eli zlecenie nie zostanie odnalezione kontroler zwraca odpowiedŸ o statusie \texttt{400 Bad request}.




\begin{lstlisting}[label={lst:confirm_target},caption={Fragment kontrolera zleceñ}]
$$@RestController
%%@RequestMapping(value = %%"api"%%)%%
public class TargetController {

    $$@Autowired
    TargetService targetService;

    $$@Autowired
    UserService userService;

    $$@Autowired
    CodeService codeService;

    %%@RequestMapping(value = %%"target/confirm"%%, method = %%RequestMethod.PATCH%%)%%
    public ResponseEntity<Target> confirm(
	%%@RequestParam(%%"target"%%)%% long target_id, 
		%%@RequestParam(%%"code"%%)%% String codeString) {
        Optional<Target> target = targetService.findById(target_id);
        if(target.isPresent()){
        Optional<Code> code = codeService.getCodeForUser(
		target.get().getHunted());
            if(code.isPresent() && code.get().getCode().equals(codeString)){
               return ResponseEntity.ok(targetService.confirm(
				target.get(), code.get()));
            }
        }

        return ResponseEntity.badRequest().body(null);
    }
}
\end{lstlisting}

Po pobraniu zlecenia z bazy odczytywany jest ostatni kod wygenerowany przez u¿ytkownika bêd¹cego Szukanym w zleceniu. Kod przes³any jako parametr zapytania jest porównywany z pobranym kodem. Je¿eli s¹ one jednakowe, kontroler przekazuje obiekt zlecenia do serwisu w celu potwierdzenia. 

Serwis ustawia status i datê wykonania zlecenia, a tak¿e przypisuje lokalizacjê, w której zlecenie zosta³o wykonane na podstawie uzytego kodu. Po wykonaniu zapisu do bazy zmodyfikowany obiekt jest zwracany do kontrolera.

\begin{lstlisting}[label={lst:confirm_service},caption={Metoda serwisu \texttt{TargetService} potwierdzaj¹ca wykonanie zlecenia}]

    public Target confirm(Target target, Code code) {
        target.setCompleted(new Date());
        target.setStatus("COMPLETED");
        target.setLocation(code.getLocation());
        targetDao.save(target);
        return target;
    }
		
		

\end{lstlisting}

Kontroler po otrzymaniu zmodyfikowanego obiektu przesy³a go w odpowiedz na zapytanie htpp ze statusem \texttt{200 Ok}.

\subsection{Automatyzacja dzia³ania systemu}\indent \par
		
		W celu umozliwienia wykonywania czêœci zadañ serwera automatycznie w okreœlonych odstêpach czasu wykorzystano funkcjonalnoœæ planowania zadañ frameworka Spring. Uaktywnienie funkcjonalnoœci wymaga utworzenia konfiguracji z uzytciem adnotacji \texttt{@EnableScheduling}. W konfiguracji przedstawionej na listingu \ref{lst:scheduler_config} wyspecyfikowano tak¿e liczbê w¹tków zadañ, jakie mog¹ zostaæ przydzielone. Je¿eli w¹tków by³oby zbyt ma³o, zaplanowane zadania by³yby opóŸniane a¿ do momentu ukoñczenia aktywnych zadañ i zwolnienia w¹tku.
		
		\begin{lstlisting}[label={lst:scheduler_config},caption={Konfiguracja planera zadañ}]
$$@Configuration
$$@EnableScheduling
public class SchedulerConfig {

    $$@Bean
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(10);
    }
}
\end{lstlisting}
		
Do tworzenia zadañ s³u¿y adnotacja \texttt{@Scheduled}. Klasa, w której tworzone s¹ zadania musi posiadaæ adnotacjê \texttt{@Component}, mówi¹c¹ o tym, ¿e jest zarz¹dzana przez Spring i mo¿e dziêki temu zostaæ odnaleziona podczas skanowania klas przy uruchamianiu aplikacji. 

Adnotacja \texttt{@Scheduled} przyjmuje jeden z dostepnych parametrów ustalaj¹cych sposób powtarzania zadañ: 
\begin{itemize}
	\item fixedRate - opóŸnienie kolejnego wykonania liczone jest od rozpoczêcia poprzedniego
	\item fixedDelay - opóŸnienie kolejnego wykonania liczone jest od zakoñczenia poprzedniego
	\item cron - czas wykonywania zadania definiowany jest przy pomocy wyra¿enia \texttt{cron}
\end{itemize}
		
Sposób tworzenia wyra¿eñ \texttt{cron} przedstawia poni¿sza tabela.

\begin{table}[H]
\begin{tabular}{lcll}
\textbf{jednostka czasu} & \textbf{wymagane} & \textbf{dozwolone wartoœci} & \textbf{znaki specialne}\\ \hline
sekundy &Y &0-59 &, - * / \\
minuty &Y& 0-59& , - * / \\
godziny&Y& 0-23 &, - * / \\
dzieñ miesi¹ca &Y &1-31 &, - * ? / L W \\
miesi¹c &Y &0-11 lub JAN-DEC &, - * / \\
dzieñ tygodnia & Y &1-7 or SUN-SAT& , - * ? / L \# \\
rok &N &puste lub 1970-2099 &, - * / \\
\end{tabular}
\caption{Parametry wyra¿eñ cron}
\label{table:cron}
\end{table}
\begin{description}
\tiny
\item [*] - ka¿da wartoœæ
\item [?] - wartoœæ dowolna
\item [-] - zakres
\item [,] - wiele wartoœci
\item [/] - wartoœæ inkrementowana, np. */5 - co 5 minut
\item [L] - ostatnia wartoœæ, np. 5L - ostatni pi¹tek miesi¹ca
\item [W] - najbli¿szy dzieñ roboczy
\item [\#] - kolejny numer wyst¹pienia, np. 6\#3 - trzeci pi¹tek miesi¹ca
\end{description}	
			
Na przyk³ad:

\begin{description}
\item [0 15 10 * * ? 2005] - uruchom o 10:15 ka¿dego dnia w roku 2005
\item [0 0/5 14 * * ?] - uruchom co 5 minut, zaczynaj¹c od 14:00, do 14:55 w³¹cznie, ka¿dego dnia
\item [0 15 10 ? * 6L 2002-2005] - uruchom o 10:15, w ka¿dy ostatni pi¹tek miesi¹ca w latach od 2002 do 2005 w³¹cznie
\end{description}
		
		
		Dodatkowym parametrem, który mo¿na przekazaæ w adnotacji \texttt{@Scheduled} jest \texttt{initialDelay} pozwalaj¹cy okreœliæ opóŸnienie rozpoczêcia wykonywania zadania po raz pierwszy po uruchomieniu aplikacji.
		
\subsubsection{Przyk³ady implementacji zadañ w projekcie}

\begin{enumerate}
	\item \textbf{Generowanie nowych zleceñ.} Schemat powtarzania tego zadania okreœla wyra¿enie \texttt{
	cron = "0 0 0/12 * * ?"}, które interpretowane jest jako "`co 12 godzin, ka¿dego dnia, zaczynaj¹c o pó³nocy"'.
	Generowanie zleceñ rozpoczyna siê od pobrania z bazy danych listy u¿ytkowników, którzy posiadaj¹ mniej ni¿ maksymalna dozwolona liczba zleceñ prywatnych. Ze wzglêdu na z³o¿onoœæ zapytania, konieczne by³o jego zdefiniowanie rêczne przy pomocy adnotacji \texttt{Query}, co zaprezentowano na listingu \ref{lst:query} w dziale \ref{db} \nameref{db}.
	
	Nastêpnie, dla ka¿dego u¿ytkownika tworzona jest lista u¿ytkowników znajduj¹cych siê w pobli¿u na podstawie zapamiêtanej ostatniej ich lokalizacji. Z utworzonej listy losowanych jest tylu u¿ytkowników, aby uzupe³niæ zlecenia do maksymalnej wartoœci.
	
	
	\begin{lstlisting} [label={lst:generate_task},caption={Zadanie generuj¹ce nowe zlecenia}]
%%@Scheduled(cron = %%"0 0 0/12 * * ?"%%)%%
public void createNewTargets() {
        List<User> hunters = targetService
	.findByTargetCountLessThan(Preferences.MAX_PRIVATE_TARGETS);
        for (User u : hunters) {
            List<User> potentialTargets = userService
				.findNearbyPlayers(u);
            for (int i = 0; i < Preferences.MAX_PRIVATE_TARGETS
		- targetService.countTargetsOf(u); i++) {
                Random r = new Random();
                int id = r.nextInt() % potentialTargets.size();
                targetService.createTarget(u.getId(), id, false);
                potentialTargets.remove(id);
            }
        }
    }
		
		\end{lstlisting}
		
		Sposób implementacji funkcji wyszukiwania graczy zosta³ zaprezentowany na poni¿szym listingu. 
		
\begin{lstlisting} [label={lst:distance},caption={Pobieranie listy u¿ytkowników z uwzglêdnieniem odleg³oœci}]

    public List<User> findNearbyPlayers(User u) {
        List<User> results = new ArrayList<>();
        List<User> activeUsers = userDAO.findByStatus(Users.ACTIVE);
        for(User a : activeUsers){
            if(a!= u && getDistance(a,u)){
                results.add(a);
            }
        }
        return results;
    }

    private boolean getDistance(User a, User u) {
        return distance(a.getLatitude(),u.getLatitude(),
			a.getLongitude(),u.getLongitude(),0,0)
			<= u.getTargetDistance();
    }

    public static double distance(double lat1, double lat2, double lon1,
                                  double lon2, double el1, double el2) {

        final int R = 6371; // Radius of the earth

        Double latDistance = Math.toRadians(lat2 - lat1);
        Double lonDistance = Math.toRadians(lon2 - lon1);
        Double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
        + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
        * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
        Double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        double distance = R * c * 1000; // convert to meters

        double height = el1 - el2;

        distance = Math.pow(distance, 2) + Math.pow(height, 2);

        return Math.sqrt(distance);
    }
\end{lstlisting}

Funkcja obliczaj¹ca odleg³oœæ dwóch punktów na podstawie wspó³rzêdnych zosta³a zaczerpniêta z  serwisu StackOverflow\ref{bib:stack_distance}.


	\item \textbf{Zmiana widocznoœci zleceñ z prywatnych na publiczne}. Aby mo¿liwe by³o utrzymanie spójnoœci danych, konieczne jest czêste wykonywanie aktualizacji. Z tego powodu to zadanie wywo³ywane jest co 10 sekund. Podczas wykonywania pobierana jest lista zleceñ prywatnych, które przekroczy³y czas przydzielone na ich potwierdzenie. Odpowiednie zapytanie zaprezentowano na listingu \ref{lst:expired_service}. Nastêpnie ka¿de zlecenie jest modyfikowane przez zmianê widocznoœci na publiczne, nadanie nowej daty utworzenia w celu zrestartowania wa¿noœci i usuniêcie przypisania do u¿ytkownika Szukaj¹cego.
	
		\begin{lstlisting} [label={lst:public_task},caption={Zadanie zmieniaj¹ce widocznoœæ zleceñ}]
%%@Scheduled(fixedRate = %%10 * 1000%%)%%
public void makePublicTargets() {
        List<Target> targetList = targetService.findExpired(false);
        for (Target t : targetList) {
            t.setPublicTarget(true);
            t.setCreated(new Date());
            t.setHunter(null);
            targetService.save(t);
        }
    }
	
		\end{lstlisting}
		
			\begin{lstlisting} [label={lst:expired_service},caption={Metoda serwisu \texttt{TargetService} pobieraj¹ca zlecenia wymagaj¹ce zmian.}]
			
public List<Target> findExpired(boolean publi) {
        LocalDateTime daysAgo = LocalDateTime.now()
		.minusDays(Preferences.PRIVATE_TARGET_DAYS);
        return targetDao.findByPublicTargetAndStatusAndCreatedBefore(
		publi,Targets.ACTIVE,Date.from(daysAgo.atZone(
		ZoneId.systemDefault()).toInstant()));
    }
\end{lstlisting}
		
\end{enumerate}
		
		
\section{Aplikacja kliencka}\indent \par

Ta sekcja opisuje proces implementacji aplikacji mobilnej przeznaczonej dla graczy.

		\subsection{Struktura projektu}\indent \par
		Projekt zosta³ wykonany w programie Android Studio w wersji 2.1.3. W plikach projektu wyró¿niæ mo¿na dwie zasadnicze grupy: klasy w jêzyku Java oraz pliki zasobów. 
		Pliki klas podzielone zosta³y w pakiety zgodnie z ich przeznaczeniem:
		\begin{itemize}
			\item activity - zawiera klasy \texttt{Activity} widoków dostêpnych w aplikacji
			\item api - klasy dostarczaj¹ce funkcjonalnoœci komunikacji z serwerem poprzez zapytania http
			\item constant - wartoœci sta³ych wykorzystywanych w projekcie
			\item fragment - zawiera klasy fragmentów bêd¹cych zawartoœci¹ klas \texttt{Activity}
			\item model - zawiera definicje obiektów reprezentuj¹cych rzeczywiste dane, na których operuje system
			\item util - zawiera klasy wspomagaj¹ce dostarczaj¹ce funkcjonalnoœci przetwarzania danych poprzez statyczne metody
			\item view - zawiera niestandardowe klasy komponentów widoku 

		\end{itemize}
		
		
		Struktura plików zasobów jest okreœlona z góry dla wszystkich projektów. Wyró¿niæ mo¿na nastêpuj¹ce foldery: 
		\begin{itemize}
			\item drawable - obrazy oraz pliki xml elementów widoku
			\item layout - pliki interfejsu graficznego aplikacji
			\item menu - lista opcji dostêpnych na ró¿nych menu aplikacji
			\item mipmap - ikony aplikacji
			\item values - pliki xml okreœlaj¹ce wartoœci takie jak kolory, wymiary, style u¿ywane w aplikacji
		\end{itemize}
		
		
		Oprócz  opisanych powy¿ej plików istotn¹ rolê w projekcie pe³ni¹ dwa pliki \texttt{build.gradle} pozwalaj¹ce na konfiguracje projektu oraz do³¹czanie bibliotek.
		
		\subsection{Konfiguracja projektu}\indent \par
		\subsection{Biblioteki wykorzystane w projekcie}\indent \par
		
		W celu poszerzenia funkcjonalnoœci dostêpnych w projektach Androida i zaoszczêdzenia czasu programowania stosuje siê biblioteki do³¹czane poprzez plik \texttt{gradle.build}. Biblioteki do³¹cza siê poprzez podanie zale¿noœci w sekcji \texttt{dependencies\{\}}. 
		
		Poni¿sza lista przedstawia wszystkie biblioteki wykorzystywane w projekcie. Wybrane z nich zostan¹ szerzej opisane w dalszej czêœci pracy.
		
		\begin{itemize}
			\item ButterKnife - biblioteka pozwala na wstrzykiwanie elementów widoków z pliku xml do klas Javy
			\item FastAdapter - biblioteka u³atwiaj¹ca tworzenie list z wykorzystaniem komponentu \texttt{RecyclerView}
			\item AppCompat - biblioteka dostarczana przez Google, zapewniaj¹ca kompatybilnoœæ ze starszymi wersjami systemu Android
			\item Design - biblioteka Google dostarczaj¹ca komponentów widoków
			\item Circular Image View - element interfejsu pozwalaj¹cy na utworzenie okr¹g³ebo obrazu
			\item Gson - biblioteka pozwalaj¹ca na konwersjê pomiêdzy obiektami Javy a ich reprezentacj¹ w formacie JSON
			\item Retrofit - klient HTTP dla Androida pozwalaj¹cy na wygodne tworzenie zapytañ HTTP 
			\item Joda - dostarcza funkcjonalnoœci pozwalaj¹cych na wygodne przetwarzanie dat i czasu z uwzglêdnieniem stref czasowych
			\item Universal Image Loader - pozwala na ³adowanie obrazów z ró¿nych Ÿróde³ w tle, pozwalaj¹c na p³ynn¹ pracê aplikacji bez obci¹¿ania interfejsu
			\item Android Image Cropper - dostarcza funkcjonalnoœæ przycinania zdjêæ wykorzystywan¹ podczas rejestracji konta
			\item Hold To Load Layout - widok w kszta³cie ko³a wyœwietlaj¹cy pasek ³adowania wokó³ siebie podczas d³ugiego wciœniêcia
			\item Okhttp3 Logging Interceptor - rozszerzenie dla biblioteki Retrofit opartej na Okhttp3 pozwalaj¹ce na wyœwietlanie zapytañ HTTP w logach aplikacji i na konsoli
			\item Number Progress Bar - pasek postêpu z numeryczn¹ reprezentacj¹ poziomu ukoñczenia w procentach
			\item Play Services - us³ugi dostarczane przez Google, niezbêdne do wykorzystania API Google Maps
			\item Swipe Reveal Layout - komponent interfejsu pozwalaj¹cy na umieszczenie dwóch widoków ponad sob¹ i odkrywanie ich gestem przeci¹gniêcia po ekranie
			\item Google Maps - obs³uga Google Maps 
			\item Circular Progress Bar - pasek postêpu w kszta³cie okrêgu, wykorzystywany jako odliczanie czasu
			
		\end{itemize}
		\subsection{Tworzenie interfejsu aplikacji}\indent \par
		
Interfejs u¿ytkownika w aplikacjach na systemy Android tworzony jest przy pomocy plików XML znajduj¹cych siê w katalogu \texttt{res/layout} projektu. Do tworzenia interfejsu wykorzystuje siê standardowe komponenty dostarczane przez œrodowisko Android, jak np. Button, ImageView, EditText itp. Komponenty osadza siê kontenerach okreœlaj¹cych ich uk³ad na ekranie, np. LinearLayout, w którym elementy uk³adane s¹ jeden obok drugiego w okreœlonym kierunku(pionowo lub poziomo). Ka¿dy element widoku posiada w³aœciwoœci, którymi mo¿na zmieniaæ jego wygl¹d i zachowanie. Mo¿liwe jest wykorzystanie elementów spoza domyœlnego zestawu dostêpnego w œrodowisku, na przyk³ad poprzez do³¹czenie zewnêtrznej biblioteki lub zdefiniowanie w³asnej klasy. W takim wypadku przy deklaracji elementu w pliku XML nale¿y podaæ pe³n¹ œcie¿kê do klasy z  uwzglêdniemiem pakietu w jakim siê znajduje. Przyk³adowy plik definicji widoku wykorzystuj¹cy zewnêtrzn¹ klasê przedstawiono na listingu \ref{lst:android_xml}. Elementom interfejsu mo¿na nadawaæ identyfikatory korzystaj¹c z parametru \texttt{android:id="@+id/<nazwa>"}. Po nadajniu identyfikatora mo¿liwe jest odnalezienie elementu w klasie aktywnoœci.

\begin{lstlisting}[language=XML,label={lst:android_xml},caption={Przyk³adowy plik widoku aplikacji}]
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent" 
              android:background="@color/gray_background">
							
    <ProgressBar
            style="?android:attr/progressBarStyleHorizontal"
            android:layout_width="match_parent"
            android:layout_height="10dp"
            android:id="@+id/progressBar" 
            android:layout_gravity="bottom|center_horizontal"
	    android:indeterminate="true"/>
			
    <com.mikhaellopez.circularimageview.CircularImageView
            android:layout_marginTop="60dp"
            android:layout_gravity="center"
            app:civ_border="false"
            app:civ_shadow="false"
            android:layout_width="180dp"
            android:layout_height="180dp"
            android:src="@drawable/no_gps_logo"/>

    <TextView android:layout_width="wrap_content"
              android:layout_gravity="center"
              android:layout_height="wrap_content"
              android:textSize="38sp"
              android:text="Enable GPS\nto continue" 
              android:layout_margin="40dp"
              android:id="@+id/status_text"
              android:gravity="center_horizontal"/>

    <Button android:layout_width="match_parent"
            android:layout_height="@dimen/button_height"
            android:layout_marginLeft="@dimen/button_width_margin"
            android:id="@+id/settings"
            android:layout_marginRight="@dimen/button_width_margin"
            android:background="@color/gray_button"
            android:text="Settings"
            android:textSize="14sp"
            android:textAllCaps="false"/>
</LinearLayout>
\end{lstlisting}

Widoki w aplikacjach Android posiadaj¹ kontrolery, które pozwalaj¹ na okreœlanie ich zachowania. Klasami kontrolerów s¹ przewa¿nie klasy \texttt{Activity} lub \texttt{Fragment}. W klasach tych nastêpuje powi¹zanie pomiêdzy zdefiniowanymi elementami pliku XML a zmiennymi w kodzie programu, co pozwala na oprogramowanie ich dzia³ania. 

Bibilioteka ButterKnife pozwala na wykonywanie opisanych powi¹zañ przy pomocy adnotacji. W tym projekcie wykorzystano dwa rodzaje adnotacji: 
\begin{itemize}
	\item \texttt{@BindView} - stosowana do zmiennych klasy, wyszukuje element o zadanym id w pliku XML i przypisuje go do adnotowanej zmiennej
	\item \texttt{@OnClick} - stosowana do metod klasy, powoduje wywo³anie adnotowanej metody po klikniêciu w element widoku o okreœlonym id.
\end{itemize}

W celu uaktywnienia rozszerzenia ButterKnife w metodzie \texttt{onCreate} kontrolera po wywo³aniu metody \texttt{setContentView} przypisuj¹cej plik z definicj¹ interfejsu do kontrolera konieczne jest utworzenie powi¹zañ metod¹ \texttt{ButterKnife.bind(this);}. Fragment kodu kontrolera prezentuj¹cy opisane czynnoœci przedstawia poni¿szy listing.

\lstset{style=java}

\begin{lstlisting}[label={lst:butterknife},caption={Tworzenie powi¹zañ interfejsu przy pomocy biblioteki ButterKnife}]

public class GpsActivity extends AppCompatActivity
	implements LocationListener {

    android.location.Location lastKnown;
    boolean exitLoop = false;

    %%@BindView(%%R.id.settings%%)%%
    Button settingsButton;

    %%@BindView(%%R.id.status_text%%)%%
    TextView statusText;

    %%@Override%%
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_gps);
        ButterKnife.bind(this);
        AppVariable.locationManager = (LocationManager) getSystemService(
		Context.LOCATION_SERVICE);
        AppVariable.locationListener = this;
        getLocation();
    }
}
\end{lstlisting}

W danym momencie, w aplikacji aktywny mo¿e byæ tylko jeden widok z jednym kontrolerem. Prze³¹czanie pomiêdzy widokami realizowane jest przez intencje (ang. intent). Kontrolery widoków, które by³ uruchomione poprzednio w aplikacji pozostaj¹ uruchomione w tle, dziêki czemu mo¿liwy jest powrót do nich. Mo¿liwe jest zakoñczenie pracy kontrolera poprzez wywo³anie metody \texttt{finish()}. 

W projekcie aby zredukowaæ iloœæ powielonego kodu potrzebnego do prze³¹czania aktywnoœci zaimplementowana zosta³a klasa \texttt{IntentHelper} dostarczaj¹ca statycznych metod pozwalaj¹cych na utworzenie intencji zaledwie jedn¹ lini¹ kodu. Kod klasy zaprezentowano na listingu \ref{lst:intent_helper}. 


\begin{lstlisting}[label={lst:intent_helper},caption={Klasa \texttt{IntentHelper}}]

public class IntentHelper {
    public final static int FILE_PICK = 1001;
    public final static int GPS_SETTINGS = 1002;
    public static final int PERMISSION_GPS = 1003;

    public static void chooseFileIntent(Activity activity){
        Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
        intent.setType("image/*");
        activity.startActivityForResult(intent, FILE_PICK);
    }

    public static void startActivityIntent(Activity source,
                Class<? extends Activity> nextActivity){
        Intent  i = new Intent(source,nextActivity);
        source.startActivity(i);
    }

    public static void startActivityIntent(Activity source,
                Class<? extends Activity> nextActivity, Bundle bundle){
        Intent  i = new Intent(source,nextActivity);
        i.putExtras(bundle);
        source.startActivity(i);
    }
}

\end{lstlisting}

Jako parametry metod zwartych w klasie nale¿y podaæ kontekst Ÿród³owy, z którego wywo³ywana jest intencja oraz klasê aktywnoœci, która ma zostaæ uruchomiona. Mo¿liwe jest równie¿ podanie dodatkowych danych do uruchamianej aktywnoœci za pomoc¹ klasy \texttt{Bundle}. Wywo³anie przejœcia przedstawia listing \ref{lst:intent_helper_call}. 


\begin{lstlisting}[label={lst:intent_helper_call},caption={Wywo³anie metody klasy \texttt{IntentHelper}}]

    public void goToTargets() {
        IntentHelper.startActivityIntent(this, TargetActivity.class);
        finish();
    }
\end{lstlisting}

Je¿eli po zakoñczeniu pracy kontrolera powinny zostaæ zwrócone jakieœ dane, aktywnoœæ nale¿y wywo³aæ przy pomocy metody \texttt{startActivityForResult}. Wówczas w aktywnoœci Ÿród³owej nale¿y przeci¹¿yæ metodê \texttt{onActivityResult} pozwalaj¹c¹ na odebranie i przetworzenie zwracanych danych. Przyk³ady zastosowania tych funkcjonalnoœci zostan¹ zaprezentowane przy opisie implementacji modu³u rejestracji.


W aplikacji zaimplementowane zosta³y nastêpuj¹ce aktywnoœci:
\begin{itemize}
	\item CodeActivity - widok pozwalaj¹cy na wygenerowanie kodu potwierdzaj¹cego
	\item DetailsActivity - widok szczegó³ów zlecenia
	\item GpsActivity - widok wyœwietlany po zalogowaniu u¿ytkownika wykouj¹cy zapis lokalizacji do bazy, drug¹ jego funkcj¹ jest zablokowanie dostêpu do pozosta³ych funkcji aplikacji
	\item LoginActivity - widok logowania do konta
	\item MapActivity - widok mapy z naniesionymi znanymi lokalizacjami u¿ytkownika, wywo³ywany z poziomu szczegó³ów zlecenia
	\item TargetActivity - wikod listy zleceñ
	\item RegisterActivity - widok rejestracji konta
	\item WelcomeActivity - widok startowy aplikacji
\end{itemize}

Szczegó³y dotycz¹ce implementacji kolejnych aktywnoœci opisuj¹ kolejne sekcje tego rozdzia³u.

Aktywnoœci zadeklarowane w aplikacji musz¹ zostaæ wpisane do pliku \texttt{AndroidManifest.xml}. Plik ten dostarcza niezbêdnych informacji o zawartoœci aplikacji do systemu operacyjnego, takich jak wymagane uprawnienia aplikacji czy wersja systemu operacyjnego. Zwartoœæ tego pliku w projekcie pokazano na listingu \ref{lst:manifest}. Oprócz wymienionych powy¿ej aktywnoœci zadeklarowana zosta³a jedna dodatkowa \texttt{CropImageActivity} pochodz¹ca z biblioteki ImageCropper.



\begin{lstlisting}[language= XML, label={lst:manifest},caption={Plik \texttt{AndroidManifest.xml}}]

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="mafia.adamzimny.mafia">

 <uses-permission android:name="android.permission.INTERNET"/>
 <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
 <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
 <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>

    <application
            android:allowBackup="true"
            android:icon="@mipmap/ic_launcher"
            android:label="@string/app_name"
            android:supportsRtl="true"
            android:theme="@style/AppTheme">
        <activity
                android:name=".activity.LoginActivity"
                android:label="Login"
                android:theme="@style/AppTheme.NoActionBar">
        </activity>
        <activity
                android:name=".activity.TargetActivity"
                android:label="Targets">
        </activity>
        <activity
                android:name=".activity.WelcomeActivity"
                android:label="Welcome"
                android:theme="@style/AppTheme.NoActionBar">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <activity android:name=".activity.UglyRegisterActivity">
        </activity>
        <activity android:name=".activity.DetailsActivity">
        </activity>

        <meta-data
                android:name="com.google.android.geo.API_KEY"
                android:value="@string/google_maps_key"/>

        <activity
                android:name=".activity.MapActivity"
                android:label="@string/title_activity_map">
        </activity>
        <activity android:name=".activity.GpsActivity">
        </activity>
        <activity android:name=".activity.CodeActivity">
        </activity>
        <activity android:name="com.theartofdev.edmodo.cropper.CropImageActivity"
                  android:theme="@style/Base.Theme.AppCompat"/>
    </application>

</manifest>

\end{lstlisting}

 W pliku manifest zosta³y zadeklarowane uprawnienia aplikacji:

\begin{itemize}
	\item INTERNET - pozwala na dostêp do internetu
	\item ACCESS\_FINE\_LOCATION - pozwala na pozyskanielokalizacji przy pomocy modu³u GPS
	\item ACCESS\_COARSE\_LOCATION - powzwala na pozyskanie lokalizacji przy pomocy modu³u GSM lub Wifi
	\item READ\_EXTERNAL\_STORAGE - pozwala na odczyt plików z zewnêtrznej karty pamiêci
\end{itemize}


W przypadku braku wymienionych uprawnieñ przy próbie dostêpu do zabezpieczonych zasobów aplikacja zg³osi³aby wyj¹tek \texttt{SecurityException}.

Prze³¹czanie pomiêdzy wybranymi widokami aplikacji odbywa siê za pomoc¹ bocznego panelu nawigacyjnego. Za jego utworzenie odpowiedzialny jest plik interfejsu \texttt{global.xml}, którego zawartoœæ pokazano na listingu \ref{lst:global}. W komponencie \texttt{NavigationView} umieszczono parametr \texttt{app:menu} definiuj¹cy zawartoœæ panelu.

\begin{lstlisting}[language= XML, label={lst:global},caption={Panel nawygacyjny aplikacji}]

<?xml version="1.0" encoding="utf-8"?>
<android.support.v4.widget.DrawerLayout 
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true"
    tools:openDrawer="start">

    <include
        layout="@layout/activity_target"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <android.support.design.widget.NavigationView
        android:id="@+id/nav_view"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        android:fitsSystemWindows="false"
        app:headerLayout="@layout/nav_drawer_banner"
        app:menu="@menu/activity_target_drawer"
        android:background="@color/gray_item"
    app:itemTextColor="@color/white" app:itemIconTint="@color/white"/>

</android.support.v4.widget.DrawerLayout>

\end{lstlisting}

\begin{lstlisting}[language= XML, label={lst:global},caption={Lista opcji dostêpna na panelu nawigacyjnym}]
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <group android:checkableBehavior="single">
        <item
            android:id="@+id/nav_targets"
            android:icon="@drawable/ic_menu_camera"
            android:title="Targets" />
        <item
            android:id="@+id/nav_profile"
            android:icon="@drawable/ic_menu_gallery"
            android:title="Profile" />
        <item
            android:id="@+id/nav_code"
            android:icon="@drawable/ic_menu_slideshow"
            android:title="Generate code" />
        <item
            android:id="@+id/nav_settings"
            android:icon="@drawable/ic_menu_manage"
            android:title="Settings" />
    </group>

    <item android:title="Developer">
        <menu>
            <item
                android:id="@+id/nav_feedback"
                android:icon="@drawable/ic_menu_share"
                android:title="Send feedback" />
            <item
                    android:id="@+id/nav_bug"
                    android:icon="@drawable/ic_menu_send"
                    android:title="Report a bug" />
            <item
                android:id="@+id/nav_rate"
                android:icon="@drawable/ic_menu_send"
                android:title="Rate" />
            <item
                android:id="@+id/nav_about"
                android:icon="@android:drawable/ic_dialog_info"
                android:title="About" />
        </menu>
    </item>

</menu>

\end{lstlisting}

Panel nawigacyjny dostêpny jest tylko z aktywnoœci \texttt{TargetActivity}. Obs³ug¹ klikniêæ w panelu zajmuje siê metoda \texttt{onNavigationItemSelected}. Fragment tej metody pozwalaj¹cy na uruchomienie aktywnoœci \texttt{CodeActivity} przedstawia poni¿szy listing.


\begin{lstlisting}[label={lst:navigation_click},caption={Lista opcji dostêpna na panelu nawigacyjnym}]
    
		$$@Override
    public boolean onNavigationItemSelected(MenuItem item) {
        // Handle navigation view item clicks here.
        int id = item.getItemId();

        if (id == R.id.nav_code) {
            IntentHelper.startActivityIntent(this,CodeActivity.class);
        }else if (id == R.id.nav_settings) {
            //...
        }
	

        drawer.closeDrawer(GravityCompat.START);
        return true;
    }

\end{lstlisting}




\begin{figure}[H]
\centering
\includegraphics[draft=false, width=6cm]{rys05/drawer.png}%
\caption{Panel nawigacyjny w aplikacji - implementacja}%
\label{fig:drawer_5}%
\end{figure}

		\subsection{Komunikacja z serwerem} \indent \par \label{komunikacja_android}
		
		Przesy³anie danych pomiêdzy zaimplementowanym serwerem, a opisywan¹ aplikacj¹ mobiln¹ odbywa siê przy pomocy zapytañ HTTP. Do tworzenia zapytañ wykorzystana zosta³a biblioteka Retrofit rozpowszechniana na licencji Apache 2.0\ref{apache_licence}.
		Retrofit pozwala na przekszta³cenie API HTTP w interfejs Javy, a nastêpnie przy pomocy metod i adnotacji zdefiniowanie dostêpnych adresów URL. Nastêpnie mo¿liwe jest wygenerowanie implementacji oraz obs³ugê zapytañ wysy³anych z jej pomoc¹. 
		
		\begin{lstlisting}[label={lst:retrofit_service}, caption={Przyk³adowe interfejsy zapytañ Retrofit}]
		
public interface TargetService {

    %%@GET(%%"api/target"%%)%%
    Call<List<Target>> getTargetsForUser(%%@Query(%%"user"%%)%% long id, 
	%%@Header(%%"X-Auth-Token"%%)%% String token);

    %%@PATCH(%%"api/target/confirm"%%)%%
    Call<Target> confirm(%%@Query(%%"target"%%)%%Integer target, 
	%%@Query(%%"code"%%)%% String code, %%@Header(%%"X-Auth-Token"%%)%% String token);

    %%@GET(%%"api/target"%%)%%
    Call<Target> getTargetById(%%@Query(%%"id"%%)%% long id,
	%%@Header(%%"X-Auth-Token"%%)%% String token);
}

public interface LocationService {

    %%@GET(%%"/api/location"%%)%%
    Call<List<Location>> findByUser(%%@Query(%%"user"%%)%% long id,
%%@Header(%%"X-Auth-Token"%%)%% String token);

    %%@GET(%%"/api/location"%%)%%
    Call<List<Location>> findByUserAndDateAfter(%%@Query(%%"user"%%)%% long id,
%%@Query(%%"date"%%)%% RetroDate date, %%@Header(%%"X-Auth-Token"%%)%% String token);

    %%@POST(%%"/api/location"%%)%%
    Call<Void> save(%%@Body%% Location location, 
%%@Header(%%"X-Auth-Token"%%)%% String token);

}
		\end{lstlisting}
		
		Adnotacje \texttt{@GET}, \texttt{@POST} oraz \texttt{@PATCH} widoczne na powy¿szym listingu okreœlaj¹ metodê i adres URL wywo³ania. Metody interfejsu zwracaj¹ typ \texttt{Call<?>}, którego parametrem jest typ zwracany przez zapytanie. Adnotacje \texttt{@Query} i \texttt{@Body} pozwalaj¹ na dodanie parametrów do zapytania, a \texttt{@Header} s³u¿y do przes³ania tokena autoryzuj¹cego w nag³ówku. 
		
		Sposób generowania implementacji interfejsów przedstawiono na poni¿szym listingu. Podobnie jak w przypadku klasy \texttt{IntentHelper} w celu redukcji powtarzanego kodu stworzono klasê ze statycznymi metodami pozwalaj¹c¹ w prosty sposób wygenerowaæ implementacjê poprzed podanie klasy interfejsu oraz bazowego adresu URL.
		
\begin{lstlisting}[label={lst:retrofit_builder}, caption={Klasa wspomagaj¹ca generowanie implementacji interfejsów biblioteki Retrofit}]
		
public class RetrofitBuilder {
    private static boolean useLocalhost = false;
    public static final String BASE_URL = "http://[...].com/";
    public static final String IMGUR_URL = "https://api.imgur.com/";
    public static final String LOCALHOST = "http://192.168.0.103:8080";

    public static Retrofit build(String url) {
        GsonBuilder builder = new GsonBuilder();
        HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
        OkHttpClient client = new OkHttpClient.Builder()
		.addInterceptor(interceptor).build();

        Gson gson = builder.setDateFormat("yyyy-MM-dd HH:mm:ss Z").
        create();
        return new Retrofit.Builder()
                .client(client)
                .baseUrl(url)
                .addConverterFactory(GsonConverterFactory.create(gson))
                .build();
    }

    public static Object getService(Class<?> clas, String url) {
        if(clas == ImgurService.class)
            return build(url).create(clas);
        return build(useLocalhost ? LOCALHOST : url).create(clas);
    }

}
\end{lstlisting}
		
		Przyk³ad wykorzystania opisanego mechanizmu w praktyce przedstawia listing \ref{lst:retrofit_use}.
		Po wygenerowaniu implementacji serwisu tworzona jest instancja zapytania \texttt{Call<Void> saveCall}. Nastêpnie przy pomocy metody \texttt{enqueue} dodawana jest ona do kolejki i oczekuje na obs³u¿enie. Odpowiedzi na zapytania tworzone w ten sposób obs³ugiwane s¹ w osobnym w¹tku aplikacji, dlatego konieczne jest opisanie zachowanie aplikacji po otrzymaniu odpowiedzi za pomoc¹ klasy \texttt{Callback}. Metody tej klasy wywo³ywane s¹ w g³ównym w¹tku aplikacji. 
		
		\begin{lstlisting}[label={lst:retrofit_use}, caption={U¿ycie biblioteki Retrofit}]
private void saveLoginLocation() {
    Log.d("location", "Saving location");
    LocationService service = (LocationService) RetrofitBuilder
	.getService(LocationService.class, RetrofitBuilder.BASE_URL);
    Location loc = LocationHelper.map(lastKnown, Locations.LOGIN);
    Call<Void> saveCall = service.save(loc, AppVariable.token);
    saveCall.enqueue(new Callback<Void>() {
        $$@Override
        public void onResponse(Call<Void> call, Response<Void> response) {
            Log.d("locations", "Response!" + response.code());

            if (response.code() == 200) {
                Log.d("locations", "Saved!");
                goToTargets();
            }
        }

        $$@Override
        public void onFailure(Call<Void> call, Throwable t) {
            Log.d(getClass().getSimpleName(),
		"Location saving error! " + t.getLocalizedMessage());
         }
     });
}
		
\end{lstlisting}

		
		\subsection{Rejestracja konta} \indent \par \label{rejestracja}
		
				Kontrolerem widoku jest klasa \texttt{RegisterActivity}. Rejestracja u¿ytkownika odbywa siê w czterech etapach: 
		\begin{enumerate}
			\item Wybór zdjêcia
			\item Uzupe³nienie formularza
			\item Przes³anie zdjêcia na serwer hostingowy
			\item Utworzenie konta
		\end{enumerate}
		
 Na szczycie widoku znajduje siê komponent \texttt{ImageButton}. Po jego klikniêciu uruchomiona zostanie aktywnoœæ wyboru pliku z galerii. Metoda odpowiedzialna za to wywo³anie przedstawiona zosta³a na listingu \ref{lst:choose_file}. Wykorzystuje ona opisan¹ wczeœniej klasê \texttt{IntentHelper} do utworzenia intencji. Widoczna adnotacja \texttt{@OnClick} z biblioteki ButterKnife przypisuje metodê do akcji przycisku. 
		
		
		\begin{lstlisting}[label={lst:choose_file}, caption={Wywo³anie okna wyboru obrazu}]
		
%%@OnClick(%%R.id.image_button%%)%%
public void pickPhoto() {
    IntentHelper.chooseFileIntent(this);
}
		
\end{lstlisting}
		
		
	Wywo³ywana aktywnoœæ zwraca dane w postaci adresu Uri wybranego obrazu, dlatego musi zostaæ obs³u¿ona w metodzie \texttt{onActivityResult}. Po zakoñczeniu wyboru obrazu jest on przekazywany do biblioteki Image Cropper, która pozwala na przyciêcie zdjêcia. Wynik dzia³ania aktywnoœci przyciêcia ponownie musi zostaæ obs³u¿ony.
	

				\begin{lstlisting}[label={lst:image_result}, caption={Obs³uga wyników aktywnoœci wyboru zdjêcia}]
		
	
    @Override
    protected void onActivityResult(int requestCode, int resultCode,
		Intent data) {
        if (requestCode == IntentHelper.FILE_PICK 
		&& resultCode == RESULT_OK) {
            imageUri = data.getData();
            CropImage.activity(imageUri).setFixAspectRatio(true)
                    .setGuidelines(CropImageView.Guidelines.ON)
                    .start(this);
        }

        if (requestCode == CropImage.CROP_IMAGE_ACTIVITY_REQUEST_CODE) {
            CropImage.ActivityResult result = CropImage
				.getActivityResult(data);
            if (resultCode == RESULT_OK) {
                Uri resultUri = result.getUri();
                ImageLoader imageLoader = ImageLoader.getInstance();
                imageLoader.displayImage(
		"file://" + resultUri.getPath(), imageButton);

                try {
                    croppedImage = MediaStore.Images.Media
			.getBitmap(this.getContentResolver(), resultUri);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                FaceDetector faceDetector = new FaceDetector
		.Builder(this).build();
                Frame frame = new Frame.Builder()
		.setBitmap(croppedImage).build();
                SparseArray<Face> faces = faceDetector.detect(frame);
                 faceDetector.release();

                if (faces.size() == 0) {
                    noFaceDetected.setVisibility(View.VISIBLE);
                } else if (faces.size() > 1) {
                    multipleFacesDetected.setVisibility(View.VISIBLE);
                } else if (FaceHelper.getFaceSizePercent(faces.get(0),
		croppedImage) < Params.FACE_PERCENTAGE) {
                    faceTooSmall.setVisibility(View.VISIBLE);
		} else {
                    faceDetected.setVisibility(View.VISIBLE);}
            } else if (resultCode == 
			CropImage.CROP_IMAGE_ACTIVITY_RESULT_ERROR_CODE) {
                Exception error = result.getError();
            }
        }
    }

\end{lstlisting}
		
	W celu zabezpieczenia przez wykorzystywaniem przez u¿ytkowników zdjêæ nieprzedstawiaj¹cych osób, wprowadzony zosta³ mechanizm wykrywania twarzy przy pomocy narzêdzia Mobile Vision\ref{bib:mobile_vision}.	Po zakoñczeniu przycinania zdjêcie jest one przekazywane do obiektu \texttt{FaceDetector}, a nastêpnie poddawane analizie. W zale¿noœci od liczby wykrytych twarzy, pod zdjêciem wyœwietlany jest odpowiedni komunikat. 
	
	Przyk³ad dzia³ania opisanego procesu zaprezentowano na poni¿szych rysunkach.
	
	
	\begin{figure}[H] 
  \begin{subfigure}[b]{0.5\linewidth}
    \centering
    \includegraphics[draft=false,width=.5\linewidth]{rys05/register1.png} 
    \caption{Widok formularza rejestracji} 
    \label{fig7:a} 
    \vspace{4ex}
  \end{subfigure}%% 
  \begin{subfigure}[b]{0.5\linewidth}
    \centering
    \includegraphics[draft=false,width=.5\linewidth]{rys05/register2.png} 
    \caption{Okno wyboru pliku} 
    \label{fig7:b} 
    \vspace{4ex}
  \end{subfigure} 
  \begin{subfigure}[b]{0.5\linewidth}
    \centering
    \includegraphics[draft=false,width=.5\linewidth]{rys05/register3.png} 
    \caption{Przycinanie zdjêcia} 
    \label{fig7:c} 
  \end{subfigure}%%
  \begin{subfigure}[b]{0.5\linewidth}
    \centering
    \includegraphics[draft=false,width=.5\linewidth]{rys05/register4.png}
    \caption{Efekt po wykryciu twarzy} 
    \label{fig7:d} 
  \end{subfigure} 
  \caption{Przyk³ad przebiegu procesu wyboru zdjêcia}
  \label{fig7} 
\end{figure}

	Formularz danych sk³ada siê z szeregu pól tekstowych. Szczególnym przypadkiem jest pole wyboru daty urodzenia, które wyœwietla okno dialogowe kalendarza po kliniêciu na nie. W celu wyœwietlenia okna tworzony jest obiekt \texttt{DatePickerDialog}, a do pola tekstowego dodawany jest \texttt{OnFocusChangeListener}, pozwalaj¹cy na detekcjê zmiany aktywnoœci pola. Wynik wyboru date z kalendarza obs³ugiwany jest przez interfejs \texttt{DatePickerDialog.OnDateSetListener}.
	

\begin{lstlisting}[label={lst:date_pick}, caption={Wyœwietlanie okna dialogowego kalendarza}]
$$@Override
protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_register);
        ButterKnife.bind(this);
        datePickerDialog = createDialog();
        setTitle("Register");
        ImageLoaderHelper.initialize(this);
        setSupportActionBar(toolbar);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        birthdayField.setOnFocusChangeListener(
		new View.OnFocusChangeListener() {
           $$ @Override
            public void onFocusChange(View view, boolean b) {
                if (b) {
                    datePickerDialog.show();
                }
            }
        });
        imageButton.requestFocus();
    }
	
	
public DatePickerDialog createDialog() {
        // Use the current date as the default date in the picker
        final Calendar c = Calendar.getInstance();
        int year = c.get(Calendar.YEAR);
        int month = c.get(Calendar.MONTH);
        int day = c.get(Calendar.DAY_OF_MONTH);

        // Create a new instance of DatePickerDialog and return it
        return new DatePickerDialog(this, this, year, month, day);
}

$$@Override
public void onDateSet(DatePicker datePicker, int i, int i1, int i2) {
        birthdayField.setText(i + "/" + i1 + "/" + i2);
}
	\end{lstlisting}
	
	Po wype³nieniu przez u¿ytkownika pól formularza i wciœniêciu przycisku Register u do³y strony, nastêpuje walidacja wprowadzonych danych. W przypadku wykrycia niepoprawnie uzupe³nionych pól zostaj¹ one podœwietlone, a na ekranie pokazuje siê komunikat o b³êdzie. 
	
	Je¿eli walidacja zosta³a wykonana poprawnie, konto mo¿e zostaæ utworzone. Wybrany obraz przesy³any jest na zewnêtrzny serwis hostingowy Imgur. Serwis ten zosta³ wybrany do przechowywania zdjêæ ze wzglêdu na ³atwoœæ wykorzystania:
	\begin{itemize}
		\item zdjêcia mog¹ byæ przesy³ane w dowolnym formacie
		\item nie ma koniecznoœci implementacji mechanizmów obs³ugi plików po stronie serwerowej systemu
		\item plikom automatycznie nadawane s¹ unikatowe identyfikatory, które ³atwo mo¿na zapisaæ w bazie danych
		\item w ³atwy sposób mo¿na odtworzyæ adres przes³anego pliku na podstawie identyfikatora, bez znajomoœci rozszerzenia pliku
	\end{itemize}
	Korzystanie z tego serwisu wymaga rejestracji aplikacji w celu uzyskania klucza dostêpu do API, który nale¿y przes³aæ jako parametr zapytania. Serwis Retrofit zapytañ Imgur przedstawia listing \ref{lst:imgur_api}.
	
	\begin{lstlisting}[label={lst:imgur_api}, caption={Interfejs zapytañ serwisu Imgur}]
	
	public interface ImgurService {
	
    $$@Multipart
    %%@POST(%%"3/image"%%)%%
    %%@Headers(%%"Authorization: Client-ID 9df1a76680eff2a"%%)%%
    Call<ImgurData> uploadImage(%%@Part(%%"image"%%)%% ProgressRequestBody image);
}
\end{lstlisting}
	
	Do utworzenia konta wymagane jest wykonanie trzech zapytañ http: 
	\begin{itemize}
	\item sprawdzaj¹cego dostêpnoœæ nazwy u¿ytkownika
		\item do serwisu Imgur w celu przes³ania zdjêcia 
		\item przes³anie danych konta na adres \texttt{/register/}
	\end{itemize}. 
	Ze wzglêdu na to, ¿e kolejne zapytanie mo¿e zostaæ wykonane dopiero po uzyskaniu odpowiedzi z poprzedniego, nie mo¿na zastosowaæ metody \texttt{enqueue} do wykonania zapytañ. Aby zapewniæ w³aœciw¹ kolejnoœæ wykonania zapytania zostaj¹ wykonane w zdarzeniu asynchronicznym \texttt{AsyncTask}.
	
	Korzystaj¹c z narzêdzia Retrofit tworzone s¹ serwisy, z których nastêpnie pobierane s¹ odpowiednie metody.   Zapytania wykonywane s¹ metod¹ \texttt{execute()}, która gwarantuje wykonanie ich w w¹tku, w którym zostan¹ wywo³ane. Po uzyskaniu odpowiedzi z identyfikatorem przes³anego zdjêcia jest on odzyskiwany przy pomocy metody \texttt{imgurResponse.body().getData().getId()} i przekazywany do obiektu \texttt{UserTemplate}. Po poprawnym wykonaniu zapytania tworz¹cego konto aktywnoœæ jest zamykana w metodzie \texttt{onPostExecute}.
	
	
	\begin{lstlisting}[label={lst:date_pick}, caption={Wyœwietlanie okna dialogowego kalendarza}]
public class RegisterTask extends AsyncTask<Void, Void, User> {

$$@Override
    protected void onPostExecute(User user) {
        progressBar.setVisibility(View.GONE);
            if (user != null) {
                Log.d("validator", user.toString());
                Handler handler = new Handler();

                handler.postDelayed(new Runnable() {
                    public void run() {
                        finish();
                    }
                }, 3000);
            }
        }

        %%@SuppressWarnings(%%"ConstantConditions"%%)%%
        $$@Override
        protected User doInBackground(Void... voids) {
            ImgurService imgurService = (ImgurService) RetrofitBuilder
		.getService(ImgurService.class, RetrofitBuilder.IMGUR_URL);
            UserService userService = (UserService) RetrofitBuilder
		.getService(UserService.class, RetrofitBuilder.BASE_URL);
            Call<Boolean> usernameCall = userService
		.checkUsername(template.getUsername());
            Response<Boolean> usernameResponse;
            try {
                usernameResponse = usernameCall.execute();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
        
            File file = null;
            try {

                file = new File(RegisterActivity.this.getCacheDir(), 
				"temp_profile");
                file.createNewFile();

//Convert bitmap to byte array

                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                croppedImage.compress(Bitmap.CompressFormat.PNG, 
			0 /*ignored for PNG*/, bos);
                byte[] bitmapdata = bos.toByteArray();

//write the bytes in file
                FileOutputStream fos = new FileOutputStream(file);
                fos.write(bitmapdata);
                fos.flush();
                fos.close();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
            ProgressRequestBody pBody = new ProgressRequestBody(file, 
		RegisterActivity.this);
            uploadImageCall = imgurService.uploadImage(pBody);
            Response<ImgurData> imgurResponse;
            try {
                imgurResponse = uploadImageCall.execute();
            } catch (IOException e) {
                return null;
            }
            template.setProfilePicture(imgurResponse.body()
			.getData().getId());
            Call<User> userCall = userService.register(template);
            Response<User> registeredUser;
            try {
                registeredUser = userCall.execute();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
            return registeredUser.body();
        }
    }
	
	\end{lstlisting}
	
		\subsection{Logowanie do konta} \indent \par
		
		Logowanie do konta wykonywane jest przy pomocy adresu email oraz has³a podanego przy rejestracji. Obs³ug¹ widoku
		
		\subsection{Lokalizacja urz¹dzenia} \indent \par
		\subsection{Zarz¹dzanie zleceniami} \indent \par
		\subsubsection{Lista zleceñ}
		\subsubsection{Szczegó³y zlecenia}
		\subsubsection{Mapa znanych lokalizacji u¿ytkownika}
		\subsection{Generowanie kodów potwierdzaj¹cych} \indent \par

		\subsection{} \indent \par
		\subsection{} \indent \par
		\subsection{} \indent \par
		\subsection{} \indent \par
		
Test test test2
		\section{Dalszy rozwój systemu} \indent \par