\chapter{Implementacja systemu}\indent \par

W tym rozdziale opisana zosta³a implementacja wybranych elementów zaprojektowanego systemu.


\section{Aplikacja serwerowa}\indent \par

\subsection{Wykorzystywane technologie i narzêdzia}\indent \par 

Podczas realizacji systemu wykorzystano nastêpuj¹ce technologie: 

\begin{enumerate}
	\item Java 1.8
	\item Spring Framework\ref{tech:spring} - jest to szkielet tworzenia aplikacji internetowych w jêzyku Javy dla platformy Enterprise Edition. Obecnie jest jedn¹ z najbardziej popularnych technologii na rynku ze wzglêdu na wsparcie twórców i spo³ecznoœci oraz du¿e mo¿liwoœci konfiguracyjne, po pozwala ³atwo dostosowaæ go do w³asnych potrzeb
	\item Spring Boot - rozszerzenie framworka Spring pozwalaj¹ce na uruchomienie aplikacji jak wykonywalnego programu Javy
	\item Spring Security - rozszerzenie skupiaj¹ce siê na dostarczeniu funkcjonalnoœci autentykowania i autoryzacji u¿ytkowników w aplikacjach Spring
	\item Hibernate - narzêdzie do realizacji warstwy dostêpu do danych, pozwala na przenoszenie danych pomiêdzy relacyjn¹ baz¹ danych a obiektami Javy 
	\item Swagger UI - narzêdzie generuj¹ce dokumentacjê API dostêpn¹ pod wybranym adresem URL wewn¹trz aplikacji internetowej
	\item JSON Web Token - metoda reprezentowania deklaracji uprawnie¿ u¿ytkowników pozwalaj¹ca na bezpieczne przesy³anie informacji pomiêdzy dwoma stronami
	\item Maven
	\item projekt Cerberus - w ramach tego projektu zaprezentowano implementacjê systemu bezstanowej autoryzacji u¿ytkowników z wykorzystaniem Spring Security oraz JSON Web Token.
\end{enumerate}
\subsection{Struktura plików projektu}

Projekt zosta³ wykonany w œrodowisku Intellij IDEA w wersji 2016.2 Ultimate. 
Pliki klas projektu podzielone zosta³y na paczki zgodnie z ich zastosowaniem: 

\begin{itemize}
	\item config - zawiera pliki konfiguracyjne frameworka Spring, oznaczone adnotacj¹ \texttt{@Configuration}
	\item constant - zawiera klasy definiuj¹ce sta³e u¿ywane w projekcie
	\item controller - zawiera klasy kontrolerów, które obs³uguj¹ zapytania http wysy³ane na przypisane im adresy URL i poprzez klasy service zwracaj¹ u¿ytkownikowi dane z bazy danych
	\item mapper - zawiera klasy pozwalaj¹ce na konwersje pomiêdzy klasami modelu
	\item model - zawiera definicje obiektów reprezentuj¹cych rzeczywiste dane, na których operuje system
	\item repository - zawiera interfejsy dostêpu do bazy danych (ang. DAO - database access object), w których zdefiniowane s¹ zapytania wywo³ywane przez aplikacje
	\item security - pochodz¹ce z projektu Cerberus klasy wspomagaj¹ce obs³ugê autoryzacji przy pomocy tokena
	\item service - zawiera klasy przetwarzaj¹ce dane pobrane z bazy danych przez DAO przed przekazaniem ich do kontrolera
	\item task - zawiera klasy automatyzuj¹ce zadania wykonywane przez aplikacje poprzez okresowe wywo³ywanie metod
\end{itemize}

Oprócz plików z kodem Ÿród³owym programu wa¿nym plikiem jest \texttt{pom.xml} pozwalaj¹cy na do³¹czanie do projektu zewnêtrznych bibliotek pobieranych z odpowiednich serwisów, np. Maven Repository\ref{tech:maven_repo}.

		\subsection{Zabezpieczenie dostêpu do API}\indent \par \label{zabezpieczenia}
Jako podstawê implementacji serwera wykorzystano projekt demonstracyjny Cerberus\ref{tech:cerberus} dostêpny na repozytorium GitHub na licencji MIT\ref{tech:mit}.  Konfiguracjê zabezpieczeñ tworzy siê poprzez utworzenie klasy rozszerzaj¹cej \texttt{WebSecurityConfigurerAdapter}. W tej klasie nadpisuje siê metodê \texttt{configure()}, a w niej tworzy politykê zabezpieczeñ dostêpu do API. Na listingu widocznym poni¿ej przedstawiono fragment konfiguracji, która okreœla trzy poziomy dostêpu dla ró¿nych adresów URL w zaleznoœci od zadeklarowanej grupy u¿ytkownika: 

\begin{enumerate}
	\item \texttt{USER}
\end{enumerate}

Nad deklaracj¹ klasy widnieje adnotacja \texttt{@Configuration} wskazuj¹ca na to, ¿e metody klasy mog¹ byæ wykorzystane przez Spring do tworzenia obiektów podczas uruchomienia programu.

\lstset{style=java}


\begin{lstlisting}[caption=Konfiguracja Spring Security]

$$@Configuration
$$@EnableWebSecurity
$$@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    $$@Override
    protected void configure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                .csrf()
                .disable()
                .exceptionHandling()
                .authenticationEntryPoint(this.unauthorizedHandler)
                .and()
                .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                .antMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                .antMatchers("/api/**").hasRole("USER")
                .antMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().permitAll();

        // Custom JWT based authentication
        httpSecurity
                .addFilterBefore(authenticationTokenFilterBean(), 
				UsernamePasswordAuthenticationFilter.class);
    }
\end{lstlisting}

W celu uaktywnienia filtrowania zapytañ, przed ka¿dym zapytaniem wywo³ywany jest filtr sprawdzaj¹cy obecnoœæ tokena w nag³ówku \texttt{X-Auth-Token} zapytania. Z uzyskanego tokena odczytywane s¹ dane u¿ytkownika, które nastêpnie przekazywane s¹ do filtra autoryzuj¹cego zapytania. W przypadku braku obecnoœci poprawnego tokena u¿ytkownik zostanie przekierowany na adres \texttt{/error/}.

\begin{lstlisting} 

public class AuthenticationTokenFilter 
	extends UsernamePasswordAuthenticationFilter {

  %%@Value(%%"X-Auth-Token"%%)%%
  private String tokenHeader;

  $$@Autowired
  private TokenUtils tokenUtils;

  $$@Autowired
  private UserDetailsService userDetailsService;

  $$@Override
  public void doFilter(ServletRequest request, ServletResponse response,
	 FilterChain chain) throws IOException, ServletException {

    HttpServletRequest httpRequest = (HttpServletRequest) request;
    String authToken = httpRequest.getHeader(this.tokenHeader);
    String username = this.tokenUtils.getUsernameFromToken(authToken);

    if (username != null && SecurityContextHolder
		.getContext().getAuthentication() == null) {
      UserDetails userDetails = this.userDetailsService
			.loadUserByUsername(username);
      if (this.tokenUtils.validateToken(authToken, userDetails)) {
        UsernamePasswordAuthenticationToken authentication = 
	new UsernamePasswordAuthenticationToken(userDetails, null,
				           userDetails.getAuthorities());
        authentication.setDetails(new WebAuthenticationDetailsSource()
				.buildDetails(httpRequest));
        SecurityContextHolder.getContext()
				.setAuthentication(authentication);
      }
    }

    chain.doFilter(request, response);
  }

}
\end{lstlisting}

		
\subsection{Baza danych} \indent \par \label{db}
Jako technologiê wykonania bazy danych wybrano Postgre SQL. Po³¹czenie z baz¹ danych realizowane jest przy pomocy sterownika JDBC. Parametry po³¹czenia i konfiguracja bazy danych okreœla klasa \texttt{DatabaseConfig} przedstawiona na listingu \ref{lst:db_config}. W konfiguracji definiowane jest obiekt \texttt{dataSource}, w którym zawarty jest adres bazy danych oraz dane logowania, a tak¿e dodatkowe ustawienia powi¹zane z frameworkiem Hibernate, w szczególnoœci okreœlana jest platforma bazy danych. W konfiguracji obiektu \texttt{EntityManagerFactory} odpowiedzialnego za tworzenie po³¹czeñ z baz¹ danych przekazywane s¹ ustalone wczeœniej parametry po³¹czenia, a tak¿e okreœlana jest œcie¿ka do modelu danych.
\begin{lstlisting}[label=lst:db_config,caption=Konfiguracja bazy danych]

$$@Configuration
$$@EnableTransactionManagement
%%@EnableJpaRepositories(%%"adamzimny.repository"%%)%%
public class DatabaseConfig {

    $$@Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("org.postgresql.Driver");
        dataSource.setUrl(
		"jdbc:postgresql://<database-url>");
        dataSource.setUsername("xxx");
        dataSource.setPassword("xxx");
        return dataSource;
    }

    $$@Bean
    public Properties jpaProperites() {
        Properties properties = new Properties();
        properties.setProperty("hibernate.hbm2ddl.auto", "update");
        properties.setProperty("hibernate.enable_lazy_load_no_trans", "true");
        return properties;
    }

    $$@Bean
    public HibernateJpaVendorAdapter jpaVendorAdapter() {
        HibernateJpaVendorAdapter hibernateJpaVendorAdapter
		= new HibernateJpaVendorAdapter();
        hibernateJpaVendorAdapter.setShowSql(false);
        hibernateJpaVendorAdapter
	.setDatabasePlatform("org.hibernate.dialect.PostgreSQLDialect");
        return hibernateJpaVendorAdapter;
    }

    $$@Bean
    public EntityManagerFactory entityManagerFactory() {
        HibernateJpaVendorAdapter vendorAdapter 
		= new HibernateJpaVendorAdapter();
        vendorAdapter.setGenerateDdl(true);

        LocalContainerEntityManagerFactoryBean factory 
		= new LocalContainerEntityManagerFactoryBean();
        factory.setJpaVendorAdapter(vendorAdapter);
        factory.setPackagesToScan("adamzimny.model");
        factory.setJpaVendorAdapter(jpaVendorAdapter());
        factory.setDataSource(dataSource());
        factory.setJpaProperties(jpaProperites());
        factory.afterPropertiesSet();
        return factory.getObject();
    }

    $$@Bean
    public PlatformTransactionManager transactionManager() {
        JpaTransactionManager txManager = new JpaTransactionManager();
        txManager.setEntityManagerFactory(entityManagerFactory());
        return txManager;
    }
}

\end{lstlisting}

Model fizyczny bazy danych generowany jest na podstawie klas znajduj¹cych siê w pakiecie \texttt{model}. Podczas uruchomienia aplikacji baza danych obecna na serwerze jest skanowana pod k¹tem ró¿nic z modelem. Je¿eli zostan¹ one wykryte, wykonywane s¹ modyfikacje prowadz¹ce do przeniesienia zmian z modelu na bazê danych. Du¿¹ zalet¹ tego rozwi¹zania jest brak koniecznoœci prowadzania rêcznych modyfikacji w bazie danych.

Tworzenie tabel w bazie danych zarz¹dzane jest przez dodanie odpowiednich adnotacji w klasach modelu. Przyk³adowa klasa przedstawiona zosta³a na listingu \ref{lst:model}. Adnotacja \texttt{@Entity} mówi o tym, ¿e nale¿y utworzyæ z tej klasy tabelê w bazie danych. Pole adnotowane \texttt{@Id} staje siê kluczem  g³ównym tabeli, którego wartoœci bêd¹ generowane automatycznie dziêki adnotacji \texttt{@GeneratedValue}. Klucze obce tabeli oznaczane s¹ jedn¹ z adnotacji \texttt{@OneToOne, @OneToMany, @ManyToOne, @ManyToMany}, zale¿nie od typu relacji pomiêdzy encjami.

\begin{lstlisting}[label={lst:model}, caption={Przyk³adowa klasa modelu}]
$$@Entity
public class Target {

    $$@Id
    %%@GeneratedValue(%%strategy= GenerationType.AUTO%%)%%
    Integer id;
    $$@OneToOne
    User hunted;
    $$@OneToOne
    User hunter;
    String status;

    %%@JsonFormat(pattern=%%"yyyy-MM-dd HH:mm:ss Z"%% )%%
    Date created;

    %%@JsonFormat(pattern=%%"yyyy-MM-dd HH:mm:ss Z"%%)%%
    Date completed;
    boolean publicTarget = false;

    $$@OneToOne
    Location location;
}
\end{lstlisting}

Interfejsy dostêpu do bazy danych znajduj¹ce siê w pakiecie \texttt{repository} rozszerzaj¹ klasê \texttt{JpaRepository}. Klasa ta dostarcza podstawowych metod operacji na tabelach, takich jak \texttt{save()} czy \texttt{findAll()}. Tworzenie dodatkowych zapytañ jest mo¿liwe poprzed deklaracje metod interfejsu. Nie ma koniecznoœci pisania zapytañ w jêzyku SQL, framework Hibernate dostarcza mechanizm pozwalaj¹cy na generowanie ich na podstawie nazwy metody. Nazwa powinna rozpoczynaæ siê od s³ów \texttt{findBy}, po których znajduj¹ siê nazwy kolumn w tabeli. Mo¿liwe jest równie¿ grupowanie, zliczanie i sortowanie wyników wed³ug tej samej konwencji nazewnictwa


\begin{lstlisting}[label={lst:repo},caption={Przyk³adowy interfejs DAO}]
$$@Repository
$$@Transactional
public interface LocationDAO extends JpaRepository<Location,Integer> {

    List<Location> findByUserAndDateAfter(User user, Date date);
    List<Location> findByUserAndType(User user, String type);
    List<Location> findByUser(User user);
    List<Location> findByUserOrderByDateDesc(User user);
}
\end{lstlisting}

Mechanizm tworzenia zapytañ jest jednak ograniczony do jednej tabeli. Je¿eli zapytanie wymaga po³¹czenia rekordów wielu tabel, wymagane jest u¿ycie adnotacj \texttt{@Query} nad metod¹ interfejsu oraz podanie w niej pe³nego zapytania w sk³adni SQL. Parametry zapytania nale¿y opisaæ adnotacj¹ \texttt{@Param}.


\begin{lstlisting}[label={lst:query}, caption={Zapytanie SQL zawieraj¹ce ³¹czenie tabel}]

    %%@Query(%%"select u from Target t join t.hunter u group
		by u.id having count(t) < :count"%%)%%
    List<User> findByTargetCountLessThan(%%@Param(%%"count"%%) %%long count);
		
\end{lstlisting}


\subsection{Komunikacja i przep³yw danych} \indent \par

Komunikacja pomiêdzy serwerem a aplikacjami mobilnymi realizowana jest przy pomocy zapytañ HTTP. Po poprawnym przetworzeniu zapytania wys³anego przez aplikacjê klienck¹, serwer odpowiada danymi zapisywanymi w formacie JSON.

Aplikacje tworzone przy pomocy frameworka spring cechuj¹ siê wspóln¹ architektur¹ warstwow¹ definiuj¹c¹ przep³yw informacji w systemie. Po otrzymaniu zapytania HTTP przez aplikacjê przekazywane jest ono do odpowiedniego kontrolera. Adresy obs³ugiwane przez kontroler lub jego metody okreœla siê przy pomocy adnotacji \texttt{@RequestMapping}, co pokazane na listingu \ref{lst:controller}. 

\begin{lstlisting}[label=lst:controller, caption=Przyk³adowy kontroler]
$$@EnableAutoConfiguration
$$@RestController
public class UserController {

    $$@Autowired
    UserService userService;
		
    %%@RequestMapping(value = %%"api/user/status"%%, method = %%RequestMethod.PATCH%%)%%
    public ResponseEntity<?> changeStatus(%%@RequestParam(%%"user"%%)%% long id,  
		%%@RequestParam(%%"status"%%)%% String status) {
        if ("active".equals(status) || "suspended".equals(status)) {
            Optional<User> userOptional = userService.get(id);
            if (userOptional.isPresent()) {
                User user = userOptional.get();
                user.setStatus(status);
                userService.save(user);
                return ResponseEntity.ok(userOptional.get());
            }
        }
        return ResponseEntity.badRequest().body(null);
    }
}
\end{lstlisting}

Po otrzymaniu zapytania kontroler mo¿e wywo³aæ metody klas typu \texttt{service}, które z kolei pobieraj¹ dane z bazy danych poprzez metody klas typu DAO z pakietu \texttt{repository}.

\begin{lstlisting}[label={lst:service},caption={Przyk³adowy serwis aplikacji}]
$$@Service
public class UserService {
    $$@Autowired
    UserDAO userDAO;

    public Optional<User> get(long id) {
        return userDAO.findById(id);
    }
}

\end{lstlisting}

Po zwróceniu danych z bazy w kontrolerze tworzona jest odpowiedŸ na zapytanie. Zale¿nie od przebiegu obs³ugi zapytania, ustawiany jest status odpowiedzi, a w przypadku zapytañ poprawnych (ze statusem \texttt{200 Ok}) w cia³o odpowiedzi wpisywane s¹ pobrane z bazy danych wyniki.

\subsection{Implementacja obs³ugi wybranych zapytañ}

Obs³uga zapytañ przez serwer jest w wielu przypadkach bardzo zbli¿ona. W tym dziale przedstawione zosta³y przyk³adowe realizacje wybranych wymagañ funkcjonalnych. 

\subsubsection{Rejestracja}\indent \par

Tworzenie nowych obiektów w konwencji REST realizwane jest przez zapytania typu \texttt{POST}. Rejestracja nowego konta u¿ytkownika rozpoczyna siê od przes³ania zapytania  na adres \texttt{/register/}. Zapytania wysy³ane na ten adres nale¿¹ do trzeciej grupy opisanej w punkcie \ref{prot_kom} i nie musz¹ posiadaæ tokena.

\begin{lstlisting}[label={lst:register_controller},caption={Kontroler rejestracji}]

$$@RestController
public class RegisterController {

    $$@Autowired
    UserService userService;

    %%@RequestMapping(value = %%"register"%%, method = %%RequestMethod.POST%%)%%
    public ResponseEntity<?> register(%%@RequestBody%% UserTemplate userTemplate) {
        User user = UserMapper.map(userTemplate);
        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        User u = userService.register(user);
        return ResponseEntity.ok().body(u);
    }
}

\end{lstlisting}

W kontrolerze pobierany jest przes³any parametr \texttt{userTemplate}. Przy wykorzystaniu klasy konweruj¹cej z pakietu \texttt{mapper} tworzony jest obiekt klasy \texttt{User}, która jest docelow¹ klas¹ zapisywan¹ w bazie danych.

Has³o przes³ane przez u¿ytkownika jest szyfrowane, aby nie zosta³o zapisane jawnym tekstem w bazie danych. Po zaszyfrowaniu has³a obiekt przekazywany jest do serwisu. 

\begin{lstlisting}[label={lst:user_service},caption={Metoda rejestracji u¿ytkownika w klasie \texttt{UserService}}]

    public User register(User user) {
        user.setRegisterDate(new Date());
        user.setStatus("ACTIVE");
        user.setAuthorities("ROLE_USER");

        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
        Date d;
        try {
            d = sdf.parse("01/01/1980");
        } catch (ParseException e) {
            d = new Date();
        }
        user.setNoTargetSince(d);

        userDAO.save(user);
        return user;
    }
		
\end{lstlisting}

Serwis zajmuje siê przygotowaniem obiektu do zapisu w bazie danych. Ustawiana jest data rejestracji i nadawane s¹ uprawnienia u¿ytkownika. Dodatkowo u¿ytkownikowi przypisuje siê datê, od której nie posiada on zleceñ jako rok 1980. Pozwoli to odnaleŸæ nowych u¿ytkowników w systemie sortuj¹c po dacie i nadaæ im priorytet w przydzielaniu zleceñ.

Po wykonaniu tych operacji obiekt jest zapisywany w bazie danych metod¹ \texttt{save()} klasy \texttt{UserDAO} i zwracany do kontrolera. W kontrolerze tworzona jest odpowiedŸ na zapytanie o statusie \texttt{200 Ok} informuj¹cym o poprawnym wykonaniu rejestracji, a nowo utworzony obiekt u¿ytkownika jest zwracany jako w odpowiedzi.

\subsubsection{Pobranie lokalizacji u¿ytkownika}\indent \par

Jako zapytania zwracaj¹ce dane uzytkownikowi przyj¹to zapytania \texttt{GET}. Parametrami zapytania s¹ id uzytkownika oraz data, od której nale¿y wyszukaæ lokalizacje. W sygnaturze metody przed drugim parametrem znajduje siê dopisek \texttt{required = false}. Oznacza to, ¿e parametr ten jest opcjonalny, czyli zapytanie wys³ane na adres \texttt{/api/location?user=1} równie¿ zostanie obs³u¿one przez tê metodê.

Rozpoczynaj¹c obs³ugê zapytania kontroler wyszukuje u¿ytkownika o zadanym numerze id w bazie danych. Je¿eli u¿ytkownik nie zostanie znaleziony, tworzona jest odpowiedŸ o statusie \texttt{400 Bad request}. W przypadku znalezienia u¿ytkownika, sprawdzana jest obecnoœæ opcjonalnego parametru daty i je¿eli zosta³ on podany, uwzglêdniany jest on w dalszej obs³udze zapytania przez serwis. 

\begin{lstlisting}[label={lst:location_controller},caption={Kontroler lokalizacji u¿ytkownika}]
%%@RequestMapping(value = %%"api/location"%%)%%
public class LocationController {

%%@RequestMapping(value = %%"api/location"%%, method = %%RequestMethod.GET%%)%%
    public ResponseEntity<?> findByUserAndDateAfter(
            %%@RequestParam(%%"user"%%)%% long id,
            %%@RequestParam(value = %%"date"%%, %%
			%%required =%% false%%)%% String dateString)
            throws ParseException {

        Optional<User> user = userService.get(id);
        if (user.isPresent()) {
            if (dateString != null) {
                DateFormat df = new SimpleDateFormat(
				        "yyyy-MM-dd HH:mm:ss zzz");
                Date date = df.parse(dateString);

                return ResponseEntity.ok(locationService
	    			.findByUserAndDateAfter(user.get(), date));
            } else {
                return ResponseEntity.ok(locationService
		    		.findByUser(user.get()));
            }
        }
        return ResponseEntity.badRequest().body("User not found!");
    }
}
\end{lstlisting}

Kontroler wywo³uje jedn¹ z dwóch metod serwisu zale¿nie od wartoœci parametru \texttt{date}. W obs³udze tego zapytania nie ma ¿adnej dodatkowej logiki, która musi zostaæ wykonana przez serwis, wiêc jego dzia³anie sprowadza siê do pobrania rekordów z bazy danych i ich zwrócenia.

 

\begin{lstlisting}[label={lst:location_service},caption={Metody pobierania lokalizacji w \texttt{LocationService}}]

    public List<Location> findByUserAndDateAfter(User user, Date date) {
        List<Location> list = locationDAO.findByUserAndDateAfter(user, date);
        return list;
    }
		
		    public List<Location> findByUser(User user) {
        return locationDAO.findByUser(user);
    }
	}

\end{lstlisting}

Po wykonaniu opracji na bazie danych tworzona jest odpowiedŸ na zapytanie o statusie \texttt{200 Ok}.

\subsubsection{Potwierdzenie wykonania zlecenia}\indent \par

Do wprowadzania modyfikacji u¿ywa siê metody \texttt{PATCH} zapytañ HTTP. Parametrami zapytania s¹ numer id zlecenia oraz kod potwierdzaj¹cy. Po otrzymaniu zapytania na adres \texttt{/api/target/confirm} kontroler wyszukuje zlecenie o zadanym numerze. Je¿eli zlecenie nie zostanie odnalezione kontroler zwraca odpowiedŸ o statusie \texttt{400 Bad request}.




\begin{lstlisting}[label={lst:confirm_target},caption={Fragment kontrolera zleceñ}]
$$@RestController
%%@RequestMapping(value = %%"api"%%)%%
public class TargetController {

    $$@Autowired
    TargetService targetService;

    $$@Autowired
    UserService userService;

    $$@Autowired
    CodeService codeService;

    %%@RequestMapping(value = %%"target/confirm"%%, method = %%RequestMethod.PATCH%%)%%
    public ResponseEntity<Target> confirm(
	%%@RequestParam(%%"target"%%)%% long target_id, 
		%%@RequestParam(%%"code"%%)%% String codeString) {
        Optional<Target> target = targetService.findById(target_id);
        if(target.isPresent()){
        Optional<Code> code = codeService.getCodeForUser(
		target.get().getHunted());
            if(code.isPresent() && code.get().getCode().equals(codeString)){
               return ResponseEntity.ok(targetService.confirm(
				target.get(), code.get()));
            }
        }

        return ResponseEntity.badRequest().body(null);
    }
}
\end{lstlisting}

Po pobraniu zlecenia z bazy odczytywany jest ostatni kod wygenerowany przez u¿ytkownika bêd¹cego Szukanym w zleceniu. Kod przes³any jako parametr zapytania jest porównywany z pobranym kodem. Je¿eli s¹ one jednakowe, kontroler przekazuje obiekt zlecenia do serwisu w celu potwierdzenia. 

Serwis ustawia status i datê wykonania zlecenia, a tak¿e przypisuje lokalizacjê, w której zlecenie zosta³o wykonane na podstawie uzytego kodu. Po wykonaniu zapisu do bazy zmodyfikowany obiekt jest zwracany do kontrolera.

\begin{lstlisting}[label={lst:confirm_service},caption={Metoda serwisu \texttt{TargetService} potwierdzaj¹ca wykonanie zlecenia}]

    public Target confirm(Target target, Code code) {
        target.setCompleted(new Date());
        target.setStatus("COMPLETED");
        target.setLocation(code.getLocation());
        targetDao.save(target);
        return target;
    }
		
		

\end{lstlisting}

Kontroler po otrzymaniu zmodyfikowanego obiektu przesy³a go w odpowiedz na zapytanie htpp ze statusem \texttt{200 Ok}.

\subsection{Automatyzacja dzia³ania systemu}\indent \par
		
		W celu umozliwienia wykonywania czêœci zadañ serwera automatycznie w okreœlonych odstêpach czasu wykorzystano funkcjonalnoœæ planowania zadañ frameworka Spring. Uaktywnienie funkcjonalnoœci wymaga utworzenia konfiguracji z uzytciem adnotacji \texttt{@EnableScheduling}. W konfiguracji przedstawionej na listingu \ref{lst:scheduler_config} wyspecyfikowano tak¿e liczbê w¹tków zadañ, jakie mog¹ zostaæ przydzielone. Je¿eli w¹tków by³oby zbyt ma³o, zaplanowane zadania by³yby opóŸniane a¿ do momentu ukoñczenia aktywnych zadañ i zwolnienia w¹tku.
		
		\begin{lstlisting}[label={lst:scheduler_config},caption={Konfiguracja planera zadañ}]
$$@Configuration
$$@EnableScheduling
public class SchedulerConfig {

    $$@Bean
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(10);
    }
}
\end{lstlisting}
		
Do tworzenia zadañ s³u¿y adnotacja \texttt{@Scheduled}. Klasa, w której tworzone s¹ zadania musi posiadaæ adnotacjê \texttt{@Component}, mówi¹c¹ o tym, ¿e jest zarz¹dzana przez Spring i mo¿e dziêki temu zostaæ odnaleziona podczas skanowania klas przy uruchamianiu aplikacji. 

Adnotacja \texttt{@Scheduled} przyjmuje jeden z dostepnych parametrów ustalaj¹cych sposób powtarzania zadañ: 
\begin{itemize}
	\item fixedRate - opóŸnienie kolejnego wykonania liczone jest od rozpoczêcia poprzedniego
	\item fixedDelay - opóŸnienie kolejnego wykonania liczone jest od zakoñczenia poprzedniego
	\item cron - czas wykonywania zadania definiowany jest przy pomocy wyra¿enia \texttt{cron}
\end{itemize}
		
Sposób tworzenia wyra¿eñ \texttt{cron} przedstawia poni¿sza tabela.

\begin{table}[H]
\begin{tabular}{lcll}
\textbf{jednostka czasu} & \textbf{wymagane} & \textbf{dozwolone wartoœci} & \textbf{znaki specialne}\\ \hline
sekundy &Y &0-59 &, - * / \\
minuty &Y& 0-59& , - * / \\
godziny&Y& 0-23 &, - * / \\
dzieñ miesi¹ca &Y &1-31 &, - * ? / L W \\
miesi¹c &Y &0-11 lub JAN-DEC &, - * / \\
dzieñ tygodnia & Y &1-7 or SUN-SAT& , - * ? / L \# \\
rok &N &puste lub 1970-2099 &, - * / \\
\end{tabular}
\caption{Parametry wyra¿eñ cron}
\label{table:cron}
\end{table}
\begin{description}
\tiny
\item [*] - ka¿da wartoœæ
\item [?] - wartoœæ dowolna
\item [-] - zakres
\item [,] - wiele wartoœci
\item [/] - wartoœæ inkrementowana, np. */5 - co 5 minut
\item [L] - ostatnia wartoœæ, np. 5L - ostatni pi¹tek miesi¹ca
\item [W] - najbli¿szy dzieñ roboczy
\item [\#] - kolejny numer wyst¹pienia, np. 6\#3 - trzeci pi¹tek miesi¹ca
\end{description}	
			
Na przyk³ad:

\begin{description}
\item [0 15 10 * * ? 2005] - uruchom o 10:15 ka¿dego dnia w roku 2005
\item [0 0/5 14 * * ?] - uruchom co 5 minut, zaczynaj¹c od 14:00, do 14:55 w³¹cznie, ka¿dego dnia
\item [0 15 10 ? * 6L 2002-2005] - uruchom o 10:15, w ka¿dy ostatni pi¹tek miesi¹ca w latach od 2002 do 2005 w³¹cznie
\end{description}
		
		
		Dodatkowym parametrem, który mo¿na przekazaæ w adnotacji \texttt{@Scheduled} jest \texttt{initialDelay} pozwalaj¹cy okreœliæ opóŸnienie rozpoczêcia wykonywania zadania po raz pierwszy po uruchomieniu aplikacji.
		
\subsubsection{Przyk³ady implementacji zadañ w projekcie}

\begin{enumerate}
	\item \textbf{Generowanie nowych zleceñ.} Schemat powtarzania tego zadania okreœla wyra¿enie \texttt{
	cron = "0 0 0/12 * * ?"}, które interpretowane jest jako "`co 12 godzin, ka¿dego dnia, zaczynaj¹c o pó³nocy"'.
	Generowanie zleceñ rozpoczyna siê od pobrania z bazy danych listy u¿ytkowników, którzy posiadaj¹ mniej ni¿ maksymalna dozwolona liczba zleceñ prywatnych. Ze wzglêdu na z³o¿onoœæ zapytania, konieczne by³o jego zdefiniowanie rêczne przy pomocy adnotacji \texttt{Query}, co zaprezentowano na listingu \ref{lst:query} w dziale \ref{db} \nameref{db}.
	
	Nastêpnie, dla ka¿dego u¿ytkownika tworzona jest lista u¿ytkowników znajduj¹cych siê w pobli¿u na podstawie zapamiêtanej ostatniej ich lokalizacji. Z utworzonej listy losowanych jest tylu u¿ytkowników, aby uzupe³niæ zlecenia do maksymalnej wartoœci.
	
	
	\begin{lstlisting} [label={lst:generate_task},caption={Zadanie generuj¹ce nowe zlecenia}]
%%@Scheduled(cron = %%"0 0 0/12 * * ?"%%)%%
public void createNewTargets() {
        List<User> hunters = targetService
	.findByTargetCountLessThan(Preferences.MAX_PRIVATE_TARGETS);
        for (User u : hunters) {
            List<User> potentialTargets = userService
				.findNearbyPlayers(u);
            for (int i = 0; i < Preferences.MAX_PRIVATE_TARGETS
		- targetService.countTargetsOf(u); i++) {
                Random r = new Random();
                int id = r.nextInt() % potentialTargets.size();
                targetService.createTarget(u.getId(), id, false);
                potentialTargets.remove(id);
            }
        }
    }
		
		\end{lstlisting}
		
		Sposób implementacji funkcji wyszukiwania graczy zosta³ zaprezentowany na poni¿szym listingu. 
		
\begin{lstlisting} [label={lst:distance},caption={Pobieranie listy u¿ytkowników z uwzglêdnieniem odleg³oœci}]

    public List<User> findNearbyPlayers(User u) {
        List<User> results = new ArrayList<>();
        List<User> activeUsers = userDAO.findByStatus(Users.ACTIVE);
        for(User a : activeUsers){
            if(a!= u && getDistance(a,u)){
                results.add(a);
            }
        }
        return results;
    }

    private boolean getDistance(User a, User u) {
        return distance(a.getLatitude(),u.getLatitude(),
			a.getLongitude(),u.getLongitude(),0,0)
			<= u.getTargetDistance();
    }

    public static double distance(double lat1, double lat2, double lon1,
                                  double lon2, double el1, double el2) {

        final int R = 6371; // Radius of the earth

        Double latDistance = Math.toRadians(lat2 - lat1);
        Double lonDistance = Math.toRadians(lon2 - lon1);
        Double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
        + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
        * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
        Double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        double distance = R * c * 1000; // convert to meters

        double height = el1 - el2;

        distance = Math.pow(distance, 2) + Math.pow(height, 2);

        return Math.sqrt(distance);
    }
\end{lstlisting}

Funkcja obliczaj¹ca odleg³oœæ dwóch punktów na podstawie wspó³rzêdnych zosta³a zaczerpniêta z  serwisu StackOverflow\ref{bib:stack_distance}.


	\item \textbf{Zmiana widocznoœci zleceñ z prywatnych na publiczne}. Aby mo¿liwe by³o utrzymanie spójnoœci danych, konieczne jest czêste wykonywanie aktualizacji. Z tego powodu to zadanie wywo³ywane jest co 10 sekund. Podczas wykonywania pobierana jest lista zleceñ prywatnych, które przekroczy³y czas przydzielone na ich potwierdzenie. Odpowiednie zapytanie zaprezentowano na listingu \ref{lst:expired_service}. Nastêpnie ka¿de zlecenie jest modyfikowane przez zmianê widocznoœci na publiczne, nadanie nowej daty utworzenia w celu zrestartowania wa¿noœci i usuniêcie przypisania do u¿ytkownika Szukaj¹cego.
	
		\begin{lstlisting} [label={lst:public_task},caption={Zadanie zmieniaj¹ce widocznoœæ zleceñ}]
%%@Scheduled(fixedRate = %%10 * 1000%%)%%
public void makePublicTargets() {
        List<Target> targetList = targetService.findExpired(false);
        for (Target t : targetList) {
            t.setPublicTarget(true);
            t.setCreated(new Date());
            t.setHunter(null);
            targetService.save(t);
        }
    }
	
		\end{lstlisting}
		
			\begin{lstlisting} [label={lst:expired_service},caption={Metoda serwisu \texttt{TargetService} pobieraj¹ca zlecenia wymagaj¹ce zmian.}]
			
public List<Target> findExpired(boolean publi) {
        LocalDateTime daysAgo = LocalDateTime.now()
		.minusDays(Preferences.PRIVATE_TARGET_DAYS);
        return targetDao.findByPublicTargetAndStatusAndCreatedBefore(
		publi,Targets.ACTIVE,Date.from(daysAgo.atZone(
		ZoneId.systemDefault()).toInstant()));
    }
\end{lstlisting}
		
\end{enumerate}
		
		
\section{Aplikacja kliencka}\indent \par

Ta sekcja opisuje proces implementacji aplikacji mobilnej przeznaczonej dla graczy.

		\subsection{Struktura projektu}\indent \par
		Projekt zosta³ wykonany w programie Android Studio w wersji 2.1.3. W plikach projektu wyró¿niæ mo¿na dwie zasadnicze grupy: klasy w jêzyku Java oraz pliki zasobów. 
		Pliki klas podzielone zosta³y w pakiety zgodnie z ich przeznaczeniem:
		\begin{itemize}
			\item activity - zawiera klasy \texttt{Activity} widoków dostêpnych w aplikacji
			\item api - klasy dostarczaj¹ce funkcjonalnoœci komunikacji z serwerem poprzez zapytania http
			\item constant - wartoœci sta³ych wykorzystywanych w projekcie
			\item fragment - zawiera klasy fragmentów bêd¹cych zawartoœci¹ klas \texttt{Activity}
			\item model - zawiera definicje obiektów reprezentuj¹cych rzeczywiste dane, na których operuje system
			\item util - zawiera klasy wspomagaj¹ce dostarczaj¹ce funkcjonalnoœci przetwarzania danych poprzez statyczne metody
			\item view - zawiera niestandardowe klasy komponentów widoku 

		\end{itemize}
		
		
		Struktura plików zasobów jest okreœlona z góry dla wszystkich projektów. Wyró¿niæ mo¿na nastêpuj¹ce foldery: 
		\begin{itemize}
			\item drawable - obrazy oraz pliki xml elementów widoku
			\item layout - pliki interfejsu graficznego aplikacji
			\item menu - lista opcji dostêpnych na ró¿nych menu aplikacji
			\item mipmap - ikony aplikacji
			\item values - pliki xml okreœlaj¹ce wartoœci takie jak kolory, wymiary, style u¿ywane w aplikacji
		\end{itemize}
		
		
		Oprócz  opisanych powy¿ej plików istotn¹ rolê w projekcie pe³ni¹ dwa pliki \texttt{build.gradle} pozwalaj¹ce na konfiguracje projektu oraz do³¹czanie bibliotek.
		
		\subsection{Biblioteki wykorzystane w projekcie}\indent \par
		
		W celu poszerzenia funkcjonalnoœci dostêpnych w projektach Androida i zaoszczêdzenia czasu programowania stosuje siê biblioteki do³¹czane poprzez plik \texttt{gradle.build}. Biblioteki do³¹cza siê poprzez podanie zale¿noœci w sekcji \texttt{dependencies\{\}}. 
		
		Poni¿sza lista przedstawia wszystkie biblioteki wykorzystywane w projekcie. Wybrane z nich zostan¹ szerzej opisane w dalszej czêœci pracy.
		
		\begin{itemize}
			\item ButterKnife - biblioteka pozwala na wstrzykiwanie elementów widoków z pliku xml do klas Javy
			\item FastAdapter - biblioteka u³atwiaj¹ca tworzenie list z wykorzystaniem komponentu \texttt{RecyclerView}
			\item AppCompat - biblioteka dostarczana przez Google, zapewniaj¹ca kompatybilnoœæ ze starszymi wersjami systemu Android
			\item Design - biblioteka Google dostarczaj¹ca komponentów widoków
			\item Circular Image View - element interfejsu pozwalaj¹cy na utworzenie okr¹g³ebo obrazu
			\item Gson - biblioteka pozwalaj¹ca na konwersjê pomiêdzy obiektami Javy a ich reprezentacj¹ w formacie JSON
			\item Retrofit - klient HTTP dla Androida pozwalaj¹cy na wygodne tworzenie zapytañ HTTP 
			\item Joda - dostarcza funkcjonalnoœci pozwalaj¹cych na wygodne przetwarzanie dat i czasu z uwzglêdnieniem stref czasowych
			\item Universal Image Loader - pozwala na ³adowanie obrazów z ró¿nych Ÿróde³ w tle, pozwalaj¹c na p³ynn¹ pracê aplikacji bez obci¹¿ania interfejsu
			\item Android Image Cropper - dostarcza funkcjonalnoœæ przycinania zdjêæ wykorzystywan¹ podczas rejestracji konta
			\item Hold To Load Layout - widok w kszta³cie ko³a wyœwietlaj¹cy pasek ³adowania wokó³ siebie podczas d³ugiego wciœniêcia
			\item Okhttp3 Logging Interceptor - rozszerzenie dla biblioteki Retrofit opartej na Okhttp3 pozwalaj¹ce na wyœwietlanie zapytañ HTTP w logach aplikacji i na konsoli
			\item Number Progress Bar - pasek postêpu z numeryczn¹ reprezentacj¹ poziomu ukoñczenia w procentach
			\item Play Services - us³ugi dostarczane przez Google, niezbêdne do wykorzystania API Google Maps
			\item Swipe Reveal Layout - komponent interfejsu pozwalaj¹cy na umieszczenie dwóch widoków ponad sob¹ i odkrywanie ich gestem przeci¹gniêcia po ekranie
			\item Google Maps - obs³uga Google Maps 
			\item Circular Progress Bar - pasek postêpu w kszta³cie okrêgu, wykorzystywany jako odliczanie czasu
			
		\end{itemize}
		\subsection{Tworzenie interfejsu aplikacji}\indent \par
		
Interfejs u¿ytkownika w aplikacjach na systemy Android tworzony jest przy pomocy plików XML znajduj¹cych siê w katalogu \texttt{res/layout} projektu. Do tworzenia interfejsu wykorzystuje siê standardowe komponenty dostarczane przez œrodowisko Android, jak np. Button, ImageView, EditText itp. Komponenty osadza siê kontenerach okreœlaj¹cych ich uk³ad na ekranie, np. LinearLayout, w którym elementy uk³adane s¹ jeden obok drugiego w okreœlonym kierunku(pionowo lub poziomo). Ka¿dy element widoku posiada w³aœciwoœci, którymi mo¿na zmieniaæ jego wygl¹d i zachowanie. Mo¿liwe jest wykorzystanie elementów spoza domyœlnego zestawu dostêpnego w œrodowisku, na przyk³ad poprzez do³¹czenie zewnêtrznej biblioteki lub zdefiniowanie w³asnej klasy. W takim wypadku przy deklaracji elementu w pliku XML nale¿y podaæ pe³n¹ œcie¿kê do klasy z  uwzglêdniemiem pakietu w jakim siê znajduje. Przyk³adowy plik definicji widoku wykorzystuj¹cy zewnêtrzn¹ klasê przedstawiono na listingu \ref{lst:android_xml}. Elementom interfejsu mo¿na nadawaæ identyfikatory korzystaj¹c z parametru \texttt{android:id="@+id/<nazwa>"}. Po nadajniu identyfikatora mo¿liwe jest odnalezienie elementu w klasie aktywnoœci.

\begin{lstlisting}[language=XML,label={lst:android_xml},caption={Przyk³adowy plik widoku aplikacji}]
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent" 
              android:background="@color/gray_background">
							
    <ProgressBar
            style="?android:attr/progressBarStyleHorizontal"
            android:layout_width="match_parent"
            android:layout_height="10dp"
            android:id="@+id/progressBar" 
            android:layout_gravity="bottom|center_horizontal"
	    android:indeterminate="true"/>
			
    <com.mikhaellopez.circularimageview.CircularImageView
            android:layout_marginTop="60dp"
            android:layout_gravity="center"
            app:civ_border="false"
            app:civ_shadow="false"
            android:layout_width="180dp"
            android:layout_height="180dp"
            android:src="@drawable/no_gps_logo"/>

    <TextView android:layout_width="wrap_content"
              android:layout_gravity="center"
              android:layout_height="wrap_content"
              android:textSize="38sp"
              android:text="Enable GPS\nto continue" 
              android:layout_margin="40dp"
              android:id="@+id/status_text"
              android:gravity="center_horizontal"/>

    <Button android:layout_width="match_parent"
            android:layout_height="@dimen/button_height"
            android:layout_marginLeft="@dimen/button_width_margin"
            android:id="@+id/settings"
            android:layout_marginRight="@dimen/button_width_margin"
            android:background="@color/gray_button"
            android:text="Settings"
            android:textSize="14sp"
            android:textAllCaps="false"/>
</LinearLayout>
\end{lstlisting}

Widoki w aplikacjach Android posiadaj¹ kontrolery, które pozwalaj¹ na okreœlanie ich zachowania. Klasami kontrolerów s¹ przewa¿nie klasy \texttt{Activity} lub \texttt{Fragment}. W klasach tych nastêpuje powi¹zanie pomiêdzy zdefiniowanymi elementami pliku XML a zmiennymi w kodzie programu, co pozwala na oprogramowanie ich dzia³ania. 

Bibilioteka ButterKnife pozwala na wykonywanie opisanych powi¹zañ przy pomocy adnotacji. W tym projekcie wykorzystano dwa rodzaje adnotacji: 
\begin{itemize}
	\item \texttt{@BindView} - stosowana do zmiennych klasy, wyszukuje element o zadanym id w pliku XML i przypisuje go do adnotowanej zmiennej
	\item \texttt{@OnClick} - stosowana do metod klasy, powoduje wywo³anie adnotowanej metody po klikniêciu w element widoku o okreœlonym id.
\end{itemize}

W celu uaktywnienia rozszerzenia ButterKnife w metodzie \texttt{onCreate} kontrolera po wywo³aniu metody \texttt{setContentView} przypisuj¹cej plik z definicj¹ interfejsu do kontrolera konieczne jest utworzenie powi¹zañ metod¹ \texttt{ButterKnife.bind(this);}. Fragment kodu kontrolera prezentuj¹cy opisane czynnoœci przedstawia poni¿szy listing.

\lstset{style=java}

\begin{lstlisting}[label={lst:butterknife},caption={Tworzenie powi¹zañ interfejsu przy pomocy biblioteki ButterKnife}]

public class GpsActivity extends AppCompatActivity
	implements LocationListener {

    android.location.Location lastKnown;
    boolean exitLoop = false;

    %%@BindView(%%R.id.settings%%)%%
    Button settingsButton;

    %%@BindView(%%R.id.status_text%%)%%
    TextView statusText;

    %%@Override%%
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_gps);
        ButterKnife.bind(this);
        AppVariable.locationManager = (LocationManager) getSystemService(
		Context.LOCATION_SERVICE);
        AppVariable.locationListener = this;
        getLocation();
    }
}
\end{lstlisting}

W danym momencie, w aplikacji aktywny mo¿e byæ tylko jeden widok z jednym kontrolerem. Prze³¹czanie pomiêdzy widokami realizowane jest przez intencje (ang. intent). Kontrolery widoków, które by³ uruchomione poprzednio w aplikacji pozostaj¹ uruchomione w tle, dziêki czemu mo¿liwy jest powrót do nich. Mo¿liwe jest zakoñczenie pracy kontrolera poprzez wywo³anie metody \texttt{finish()}. 

W projekcie aby zredukowaæ iloœæ powielonego kodu potrzebnego do prze³¹czania aktywnoœci zaimplementowana zosta³a klasa \texttt{IntentHelper} dostarczaj¹ca statycznych metod pozwalaj¹cych na utworzenie intencji zaledwie jedn¹ lini¹ kodu. Kod klasy zaprezentowano na listingu \ref{lst:intent_helper}. 


\begin{lstlisting}[label={lst:intent_helper},caption={Klasa \texttt{IntentHelper}}]

public class IntentHelper {
    public final static int FILE_PICK = 1001;
    public final static int GPS_SETTINGS = 1002;
    public static final int PERMISSION_GPS = 1003;

    public static void chooseFileIntent(Activity activity){
        Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
        intent.setType("image/*");
        activity.startActivityForResult(intent, FILE_PICK);
    }

    public static void startActivityIntent(Activity source,
                Class<? extends Activity> nextActivity){
        Intent  i = new Intent(source,nextActivity);
        source.startActivity(i);
    }

    public static void startActivityIntent(Activity source,
                Class<? extends Activity> nextActivity, Bundle bundle){
        Intent  i = new Intent(source,nextActivity);
        i.putExtras(bundle);
        source.startActivity(i);
    }
}

\end{lstlisting}

Jako parametry metod zwartych w klasie nale¿y podaæ kontekst Ÿród³owy, z którego wywo³ywana jest intencja oraz klasê aktywnoœci, która ma zostaæ uruchomiona. Mo¿liwe jest równie¿ podanie dodatkowych danych do uruchamianej aktywnoœci za pomoc¹ klasy \texttt{Bundle}. Wywo³anie przejœcia przedstawia listing \ref{lst:intent_helper_call}. 


\begin{lstlisting}[label={lst:intent_helper_call},caption={Wywo³anie metody klasy \texttt{IntentHelper}}]

    public void goToTargets() {
        IntentHelper.startActivityIntent(this, TargetActivity.class);
        finish();
    }
\end{lstlisting}

Je¿eli po zakoñczeniu pracy kontrolera powinny zostaæ zwrócone jakieœ dane, aktywnoœæ nale¿y wywo³aæ przy pomocy metody \texttt{startActivityForResult}. Wówczas w aktywnoœci Ÿród³owej nale¿y przeci¹¿yæ metodê \texttt{onActivityResult} pozwalaj¹c¹ na odebranie i przetworzenie zwracanych danych. Przyk³ady zastosowania tych funkcjonalnoœci zostan¹ zaprezentowane przy opisie implementacji modu³u rejestracji.


W aplikacji zaimplementowane zosta³y nastêpuj¹ce aktywnoœci:
\begin{itemize}
	\item CodeActivity - widok pozwalaj¹cy na wygenerowanie kodu potwierdzaj¹cego
	\item DetailsActivity - widok szczegó³ów zlecenia
	\item GpsActivity - widok wyœwietlany po zalogowaniu u¿ytkownika wykouj¹cy zapis lokalizacji do bazy, drug¹ jego funkcj¹ jest zablokowanie dostêpu do pozosta³ych funkcji aplikacji
	\item LoginActivity - widok logowania do konta
	\item MapActivity - widok mapy z naniesionymi znanymi lokalizacjami u¿ytkownika, wywo³ywany z poziomu szczegó³ów zlecenia
	\item TargetActivity - wikod listy zleceñ
	\item RegisterActivity - widok rejestracji konta
	\item WelcomeActivity - widok startowy aplikacji
\end{itemize}

Szczegó³y dotycz¹ce implementacji kolejnych aktywnoœci opisuj¹ kolejne sekcje tego rozdzia³u.

Aktywnoœci zadeklarowane w aplikacji musz¹ zostaæ wpisane do pliku \texttt{AndroidManifest.xml}. Plik ten dostarcza niezbêdnych informacji o zawartoœci aplikacji do systemu operacyjnego, takich jak wymagane uprawnienia aplikacji czy wersja systemu operacyjnego. Zwartoœæ tego pliku w projekcie pokazano na listingu \ref{lst:manifest}. Oprócz wymienionych powy¿ej aktywnoœci zadeklarowana zosta³a jedna dodatkowa \texttt{CropImageActivity} pochodz¹ca z biblioteki ImageCropper.



\begin{lstlisting}[language= XML, label={lst:manifest},caption={Plik \texttt{AndroidManifest.xml}}]

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="mafia.adamzimny.mafia">

 <uses-permission android:name="android.permission.INTERNET"/>
 <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
 <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
 <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>

    <application
            android:allowBackup="true"
            android:icon="@mipmap/ic_launcher"
            android:label="@string/app_name"
            android:supportsRtl="true"
            android:theme="@style/AppTheme">
        <activity
                android:name=".activity.LoginActivity"
                android:label="Login"
                android:theme="@style/AppTheme.NoActionBar">
        </activity>
        <activity
                android:name=".activity.TargetActivity"
                android:label="Targets">
        </activity>
        <activity
                android:name=".activity.WelcomeActivity"
                android:label="Welcome"
                android:theme="@style/AppTheme.NoActionBar">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <activity android:name=".activity.UglyRegisterActivity">
        </activity>
        <activity android:name=".activity.DetailsActivity">
        </activity>

        <meta-data
                android:name="com.google.android.geo.API_KEY"
                android:value="@string/google_maps_key"/>

        <activity
                android:name=".activity.MapActivity"
                android:label="@string/title_activity_map">
        </activity>
        <activity android:name=".activity.GpsActivity">
        </activity>
        <activity android:name=".activity.CodeActivity">
        </activity>
        <activity android:name="com.theartofdev.edmodo.cropper.CropImageActivity"
                  android:theme="@style/Base.Theme.AppCompat"/>
    </application>

</manifest>

\end{lstlisting}

 W pliku manifest zosta³y zadeklarowane uprawnienia aplikacji:

\begin{itemize}
	\item INTERNET - pozwala na dostêp do internetu
	\item ACCESS\_FINE\_LOCATION - pozwala na pozyskanielokalizacji przy pomocy modu³u GPS
	\item ACCESS\_COARSE\_LOCATION - powzwala na pozyskanie lokalizacji przy pomocy modu³u GSM lub Wifi
	\item READ\_EXTERNAL\_STORAGE - pozwala na odczyt plików z zewnêtrznej karty pamiêci
\end{itemize}


W przypadku braku wymienionych uprawnieñ przy próbie dostêpu do zabezpieczonych zasobów aplikacja zg³osi³aby wyj¹tek \texttt{SecurityException}.

Prze³¹czanie pomiêdzy wybranymi widokami aplikacji odbywa siê za pomoc¹ bocznego panelu nawigacyjnego. Za jego utworzenie odpowiedzialny jest plik interfejsu \texttt{global.xml}, którego zawartoœæ pokazano na listingu \ref{lst:global}. W komponencie \texttt{NavigationView} umieszczono parametr \texttt{app:menu} definiuj¹cy zawartoœæ panelu.

\begin{lstlisting}[language= XML, label={lst:global},caption={Panel nawygacyjny aplikacji}]

<?xml version="1.0" encoding="utf-8"?>
<android.support.v4.widget.DrawerLayout 
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true"
    tools:openDrawer="start">

    <include
        layout="@layout/activity_target"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <android.support.design.widget.NavigationView
        android:id="@+id/nav_view"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        android:fitsSystemWindows="false"
        app:headerLayout="@layout/nav_drawer_banner"
        app:menu="@menu/activity_target_drawer"
        android:background="@color/gray_item"
    app:itemTextColor="@color/white" app:itemIconTint="@color/white"/>

</android.support.v4.widget.DrawerLayout>

\end{lstlisting}

\begin{lstlisting}[language= XML, label={lst:global},caption={Lista opcji dostêpna na panelu nawigacyjnym}]
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <group android:checkableBehavior="single">
        <item
            android:id="@+id/nav_targets"
            android:icon="@drawable/ic_menu_camera"
            android:title="Targets" />
        <item
            android:id="@+id/nav_profile"
            android:icon="@drawable/ic_menu_gallery"
            android:title="Profile" />
        <item
            android:id="@+id/nav_code"
            android:icon="@drawable/ic_menu_slideshow"
            android:title="Generate code" />
        <item
            android:id="@+id/nav_settings"
            android:icon="@drawable/ic_menu_manage"
            android:title="Settings" />
    </group>

    <item android:title="Developer">
        <menu>
            <item
                android:id="@+id/nav_feedback"
                android:icon="@drawable/ic_menu_share"
                android:title="Send feedback" />
            <item
                    android:id="@+id/nav_bug"
                    android:icon="@drawable/ic_menu_send"
                    android:title="Report a bug" />
            <item
                android:id="@+id/nav_rate"
                android:icon="@drawable/ic_menu_send"
                android:title="Rate" />
            <item
                android:id="@+id/nav_about"
                android:icon="@android:drawable/ic_dialog_info"
                android:title="About" />
        </menu>
    </item>

</menu>

\end{lstlisting}

Panel nawigacyjny dostêpny jest tylko z aktywnoœci \texttt{TargetActivity}. Obs³ug¹ klikniêæ w panelu zajmuje siê metoda \texttt{onNavigationItemSelected}. Fragment tej metody pozwalaj¹cy na uruchomienie aktywnoœci \texttt{CodeActivity} przedstawia poni¿szy listing.


\begin{lstlisting}[label={lst:navigation_click},caption={Lista opcji dostêpna na panelu nawigacyjnym}]
    
		$$@Override
    public boolean onNavigationItemSelected(MenuItem item) {
        // Handle navigation view item clicks here.
        int id = item.getItemId();

        if (id == R.id.nav_code) {
            IntentHelper.startActivityIntent(this,CodeActivity.class);
        }else if (id == R.id.nav_settings) {
            //...
        }
	

        drawer.closeDrawer(GravityCompat.START);
        return true;
    }

\end{lstlisting}




\begin{figure}[H]
\centering
\includegraphics[draft=false, width=6cm]{rys05/drawer.png}%
\caption{Panel nawigacyjny w aplikacji - implementacja}%
\label{fig:drawer_5}%
\end{figure}

		\subsection{Komunikacja z serwerem} \indent \par \label{komunikacja_android}
		
		Przesy³anie danych pomiêdzy zaimplementowanym serwerem, a opisywan¹ aplikacj¹ mobiln¹ odbywa siê przy pomocy zapytañ HTTP. Do tworzenia zapytañ wykorzystana zosta³a biblioteka Retrofit rozpowszechniana na licencji Apache 2.0\ref{apache_licence}.
		Retrofit pozwala na przekszta³cenie API HTTP w interfejs Javy, a nastêpnie przy pomocy metod i adnotacji zdefiniowanie dostêpnych adresów URL. Nastêpnie mo¿liwe jest wygenerowanie implementacji oraz obs³ugê zapytañ wysy³anych z jej pomoc¹. 
		
		\begin{lstlisting}[label={lst:retrofit_service}, caption={Przyk³adowe interfejsy zapytañ Retrofit}]
		
public interface TargetService {

    %%@GET(%%"api/target"%%)%%
    Call<List<Target>> getTargetsForUser(%%@Query(%%"user"%%)%% long id, 
	%%@Header(%%"X-Auth-Token"%%)%% String token);

    %%@PATCH(%%"api/target/confirm"%%)%%
    Call<Target> confirm(%%@Query(%%"target"%%)%%Integer target, 
	%%@Query(%%"code"%%)%% String code, %%@Header(%%"X-Auth-Token"%%)%% String token);

    %%@GET(%%"api/target"%%)%%
    Call<Target> getTargetById(%%@Query(%%"id"%%)%% long id,
	%%@Header(%%"X-Auth-Token"%%)%% String token);
}

public interface LocationService {

    %%@GET(%%"/api/location"%%)%%
    Call<List<Location>> findByUser(%%@Query(%%"user"%%)%% long id,
%%@Header(%%"X-Auth-Token"%%)%% String token);

    %%@GET(%%"/api/location"%%)%%
    Call<List<Location>> findByUserAndDateAfter(%%@Query(%%"user"%%)%% long id,
%%@Query(%%"date"%%)%% RetroDate date, %%@Header(%%"X-Auth-Token"%%)%% String token);

    %%@POST(%%"/api/location"%%)%%
    Call<Void> save(%%@Body%% Location location, 
%%@Header(%%"X-Auth-Token"%%)%% String token);

}
		\end{lstlisting}
		
		Adnotacje \texttt{@GET}, \texttt{@POST} oraz \texttt{@PATCH} widoczne na powy¿szym listingu okreœlaj¹ metodê i adres URL wywo³ania. Metody interfejsu zwracaj¹ typ \texttt{Call<?>}, którego parametrem jest typ zwracany przez zapytanie. Adnotacje \texttt{@Query} i \texttt{@Body} pozwalaj¹ na dodanie parametrów do zapytania, a \texttt{@Header} s³u¿y do przes³ania tokena autoryzuj¹cego w nag³ówku. 
		
		Sposób generowania implementacji interfejsów przedstawiono na poni¿szym listingu. Podobnie jak w przypadku klasy \texttt{IntentHelper} w celu redukcji powtarzanego kodu stworzono klasê ze statycznymi metodami pozwalaj¹c¹ w prosty sposób wygenerowaæ implementacjê poprzed podanie klasy interfejsu oraz bazowego adresu URL.
		
\begin{lstlisting}[label={lst:retrofit_builder}, caption={Klasa wspomagaj¹ca generowanie implementacji interfejsów biblioteki Retrofit}]
		
public class RetrofitBuilder {
    private static boolean useLocalhost = false;
    public static final String BASE_URL = "http://[...].com/";
    public static final String IMGUR_URL = "https://api.imgur.com/";
    public static final String LOCALHOST = "http://192.168.0.103:8080";

    public static Retrofit build(String url) {
        GsonBuilder builder = new GsonBuilder();
        HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
        OkHttpClient client = new OkHttpClient.Builder()
		.addInterceptor(interceptor).build();

        Gson gson = builder.setDateFormat("yyyy-MM-dd HH:mm:ss Z").
        create();
        return new Retrofit.Builder()
                .client(client)
                .baseUrl(url)
                .addConverterFactory(GsonConverterFactory.create(gson))
                .build();
    }

    public static Object getService(Class<?> clas, String url) {
        if(clas == ImgurService.class)
            return build(url).create(clas);
        return build(useLocalhost ? LOCALHOST : url).create(clas);
    }

}
\end{lstlisting}
		
		Przyk³ad wykorzystania opisanego mechanizmu w praktyce przedstawia listing \ref{lst:retrofit_use}.
		Po wygenerowaniu implementacji serwisu tworzona jest instancja zapytania \texttt{Call<Void> saveCall}. Nastêpnie przy pomocy metody \texttt{enqueue} dodawana jest ona do kolejki i oczekuje na obs³u¿enie. Odpowiedzi na zapytania tworzone w ten sposób obs³ugiwane s¹ w osobnym w¹tku aplikacji, dlatego konieczne jest opisanie zachowanie aplikacji po otrzymaniu odpowiedzi za pomoc¹ klasy \texttt{Callback}. Metody tej klasy wywo³ywane s¹ w g³ównym w¹tku aplikacji. 
		
		\begin{lstlisting}[label={lst:retrofit_use}, caption={U¿ycie biblioteki Retrofit}]
private void saveLoginLocation() {
    Log.d("location", "Saving location");
    LocationService service = (LocationService) RetrofitBuilder
	.getService(LocationService.class, RetrofitBuilder.BASE_URL);
    Location loc = LocationHelper.map(lastKnown, Locations.LOGIN);
    Call<Void> saveCall = service.save(loc, AppVariable.token);
    saveCall.enqueue(new Callback<Void>() {
        $$@Override
        public void onResponse(Call<Void> call, Response<Void> response) {
            Log.d("locations", "Response!" + response.code());

            if (response.code() == 200) {
                Log.d("locations", "Saved!");
                goToTargets();
            }
        }

        $$@Override
        public void onFailure(Call<Void> call, Throwable t) {
            Log.d(getClass().getSimpleName(),
		"Location saving error! " + t.getLocalizedMessage());
         }
     });
}
		
\end{lstlisting}

		
		\subsection{Rejestracja konta} \indent \par \label{rejestracja}
		
				Kontrolerem widoku jest klasa \texttt{RegisterActivity}. Rejestracja u¿ytkownika odbywa siê w czterech etapach: 
		\begin{enumerate}
			\item Wybór zdjêcia
			\item Uzupe³nienie formularza
			\item Przes³anie zdjêcia na serwer hostingowy
			\item Utworzenie konta
		\end{enumerate}
		
 Na szczycie widoku znajduje siê komponent \texttt{ImageButton}. Po jego klikniêciu uruchomiona zostanie aktywnoœæ wyboru pliku z galerii. Metoda odpowiedzialna za to wywo³anie przedstawiona zosta³a na listingu \ref{lst:choose_file}. Wykorzystuje ona opisan¹ wczeœniej klasê \texttt{IntentHelper} do utworzenia intencji. Widoczna adnotacja \texttt{@OnClick} z biblioteki ButterKnife przypisuje metodê do akcji przycisku. 
		
		
		\begin{lstlisting}[label={lst:choose_file}, caption={Wywo³anie okna wyboru obrazu}]
		
%%@OnClick(%%R.id.image_button%%)%%
public void pickPhoto() {
    IntentHelper.chooseFileIntent(this);
}
		
\end{lstlisting}
		
		
	Wywo³ywana aktywnoœæ zwraca dane w postaci adresu Uri wybranego obrazu, dlatego musi zostaæ obs³u¿ona w metodzie \texttt{onActivityResult}. Po zakoñczeniu wyboru obrazu jest on przekazywany do biblioteki Image Cropper, która pozwala na przyciêcie zdjêcia. Wynik dzia³ania aktywnoœci przyciêcia ponownie musi zostaæ obs³u¿ony.
	

				\begin{lstlisting}[label={lst:image_result}, caption={Obs³uga wyników aktywnoœci wyboru zdjêcia}]
		
	
    @Override
    protected void onActivityResult(int requestCode, int resultCode,
		Intent data) {
        if (requestCode == IntentHelper.FILE_PICK 
		&& resultCode == RESULT_OK) {
            imageUri = data.getData();
            CropImage.activity(imageUri).setFixAspectRatio(true)
                    .setGuidelines(CropImageView.Guidelines.ON)
                    .start(this);
        }

        if (requestCode == CropImage.CROP_IMAGE_ACTIVITY_REQUEST_CODE) {
            CropImage.ActivityResult result = CropImage
				.getActivityResult(data);
            if (resultCode == RESULT_OK) {
                Uri resultUri = result.getUri();
                ImageLoader imageLoader = ImageLoader.getInstance();
                imageLoader.displayImage(
		"file://" + resultUri.getPath(), imageButton);

                try {
                    croppedImage = MediaStore.Images.Media
			.getBitmap(this.getContentResolver(), resultUri);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                FaceDetector faceDetector = new FaceDetector
		.Builder(this).build();
                Frame frame = new Frame.Builder()
		.setBitmap(croppedImage).build();
                SparseArray<Face> faces = faceDetector.detect(frame);
                 faceDetector.release();

                if (faces.size() == 0) {
                    noFaceDetected.setVisibility(View.VISIBLE);
                } else if (faces.size() > 1) {
                    multipleFacesDetected.setVisibility(View.VISIBLE);
                } else if (FaceHelper.getFaceSizePercent(faces.get(0),
		croppedImage) < Params.FACE_PERCENTAGE) {
                    faceTooSmall.setVisibility(View.VISIBLE);
		} else {
                    faceDetected.setVisibility(View.VISIBLE);}
            } else if (resultCode == 
			CropImage.CROP_IMAGE_ACTIVITY_RESULT_ERROR_CODE) {
                Exception error = result.getError();
            }
        }
    }

\end{lstlisting}
		
	W celu zabezpieczenia przez wykorzystywaniem przez u¿ytkowników zdjêæ nieprzedstawiaj¹cych osób, wprowadzony zosta³ mechanizm wykrywania twarzy przy pomocy narzêdzia Mobile Vision\ref{bib:mobile_vision}.	Po zakoñczeniu przycinania zdjêcie jest one przekazywane do obiektu \texttt{FaceDetector}, a nastêpnie poddawane analizie. W zale¿noœci od liczby wykrytych twarzy, pod zdjêciem wyœwietlany jest odpowiedni komunikat. 
	
	Przyk³ad dzia³ania opisanego procesu zaprezentowano na poni¿szych rysunkach.
	
	
	\begin{figure}[H] 
	\centering
  \begin{subfigure}[b]{0.5\linewidth}
    \centering
    \includegraphics[draft=false,width=.5\linewidth]{rys05/register1.png} 
    \caption{Widok formularza rejestracji} 
    \label{fig7:a} 
    \vspace{4ex}
  \end{subfigure}%% 
  \begin{subfigure}[b]{0.5\linewidth}
    \centering
    \includegraphics[draft=false,width=.5\linewidth]{rys05/register2.png} 
    \caption{Okno wyboru pliku} 
    \label{fig7:b} 
    \vspace{4ex}
  \end{subfigure} 
  \begin{subfigure}[b]{0.5\linewidth}
    \centering
    \includegraphics[draft=false,width=.5\linewidth]{rys05/register3.png} 
    \caption{Przycinanie zdjêcia} 
    \label{fig7:c} 
  \end{subfigure}%%
  \begin{subfigure}[b]{0.5\linewidth}
    \centering
    \includegraphics[draft=false,width=.5\linewidth]{rys05/register4.png}
    \caption{Efekt po wykryciu twarzy} 
    \label{fig7:d} 
  \end{subfigure} 
  \caption{Przyk³ad przebiegu procesu wyboru zdjêcia}
  \label{fig7} 
\end{figure}

	Formularz danych sk³ada siê z szeregu pól tekstowych. Szczególnym przypadkiem jest pole wyboru daty urodzenia, które wyœwietla okno dialogowe kalendarza po kliniêciu na nie. W celu wyœwietlenia okna tworzony jest obiekt \texttt{DatePickerDialog}, a do pola tekstowego dodawany jest \texttt{OnFocusChangeListener}, pozwalaj¹cy na detekcjê zmiany aktywnoœci pola. Wynik wyboru date z kalendarza obs³ugiwany jest przez interfejs \texttt{DatePickerDialog.OnDateSetListener}.
	

\begin{lstlisting}[label={lst:date_pick}, caption={Wyœwietlanie okna dialogowego kalendarza}]
$$@Override
protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_register);
        ButterKnife.bind(this);
        datePickerDialog = createDialog();
        setTitle("Register");
        ImageLoaderHelper.initialize(this);
        setSupportActionBar(toolbar);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        birthdayField.setOnFocusChangeListener(
		new View.OnFocusChangeListener() {
           $$ @Override
            public void onFocusChange(View view, boolean b) {
                if (b) {
                    datePickerDialog.show();
                }
            }
        });
        imageButton.requestFocus();
    }
	
	
public DatePickerDialog createDialog() {
        // Use the current date as the default date in the picker
        final Calendar c = Calendar.getInstance();
        int year = c.get(Calendar.YEAR);
        int month = c.get(Calendar.MONTH);
        int day = c.get(Calendar.DAY_OF_MONTH);

        // Create a new instance of DatePickerDialog and return it
        return new DatePickerDialog(this, this, year, month, day);
}

$$@Override
public void onDateSet(DatePicker datePicker, int i, int i1, int i2) {
        birthdayField.setText(i + "/" + i1 + "/" + i2);
}
	\end{lstlisting}
	
	Po wype³nieniu przez u¿ytkownika pól formularza i wciœniêciu przycisku Register u do³y strony, nastêpuje walidacja wprowadzonych danych. W przypadku wykrycia niepoprawnie uzupe³nionych pól zostaj¹ one podœwietlone, a na ekranie pokazuje siê komunikat o b³êdzie. 
	
	Je¿eli walidacja zosta³a wykonana poprawnie, konto mo¿e zostaæ utworzone. Wybrany obraz przesy³any jest na zewnêtrzny serwis hostingowy Imgur. Serwis ten zosta³ wybrany do przechowywania zdjêæ ze wzglêdu na ³atwoœæ wykorzystania:
	\begin{itemize}
		\item zdjêcia mog¹ byæ przesy³ane w dowolnym formacie
		\item nie ma koniecznoœci implementacji mechanizmów obs³ugi plików po stronie serwerowej systemu
		\item plikom automatycznie nadawane s¹ unikatowe identyfikatory, które ³atwo mo¿na zapisaæ w bazie danych
		\item w ³atwy sposób mo¿na odtworzyæ adres przes³anego pliku na podstawie identyfikatora, bez znajomoœci rozszerzenia pliku
	\end{itemize}
	Korzystanie z tego serwisu wymaga rejestracji aplikacji w celu uzyskania klucza dostêpu do API, który nale¿y przes³aæ jako parametr zapytania. Serwis Retrofit zapytañ Imgur przedstawia listing \ref{lst:imgur_api}.
	
	\begin{lstlisting}[label={lst:imgur_api}, caption={Interfejs zapytañ serwisu Imgur}]
	
	public interface ImgurService {
	
    $$@Multipart
    %%@POST(%%"3/image"%%)%%
    %%@Headers(%%"Authorization: Client-ID 9df1a76680eff2a"%%)%%
    Call<ImgurData> uploadImage(%%@Part(%%"image"%%)%% ProgressRequestBody image);
}
\end{lstlisting}
	
	Do utworzenia konta wymagane jest wykonanie trzech zapytañ http: 
	\begin{itemize}
	\item sprawdzaj¹cego dostêpnoœæ nazwy u¿ytkownika
		\item do serwisu Imgur w celu przes³ania zdjêcia 
		\item przes³anie danych konta na adres \texttt{/register/}
	\end{itemize}. 
	Ze wzglêdu na to, ¿e kolejne zapytanie mo¿e zostaæ wykonane dopiero po uzyskaniu odpowiedzi z poprzedniego, nie mo¿na zastosowaæ metody \texttt{enqueue} do wykonania zapytañ. Aby zapewniæ w³aœciw¹ kolejnoœæ wykonania zapytania zostaj¹ wykonane w zdarzeniu asynchronicznym \texttt{AsyncTask}.
	
	Korzystaj¹c z narzêdzia Retrofit tworzone s¹ serwisy, z których nastêpnie pobierane s¹ odpowiednie metody.   Zapytania wykonywane s¹ metod¹ \texttt{execute()}, która gwarantuje wykonanie ich w w¹tku, w którym zostan¹ wywo³ane. Po uzyskaniu odpowiedzi z identyfikatorem przes³anego zdjêcia jest on odzyskiwany przy pomocy metody \texttt{imgurResponse.body().getData().getId()} i przekazywany do obiektu \texttt{UserTemplate}. Po poprawnym wykonaniu zapytania tworz¹cego konto aktywnoœæ jest zamykana w metodzie \texttt{onPostExecute}.
	
	
	\begin{lstlisting}[label={lst:date_pick}, caption={Wyœwietlanie okna dialogowego kalendarza}]
public class RegisterTask extends AsyncTask<Void, Void, User> {

$$@Override
    protected void onPostExecute(User user) {
        progressBar.setVisibility(View.GONE);
            if (user != null) {
                Log.d("validator", user.toString());
                Handler handler = new Handler();

                handler.postDelayed(new Runnable() {
                    public void run() {
                        finish();
                    }
                }, 3000);
            }
        }

        %%@SuppressWarnings(%%"ConstantConditions"%%)%%
        $$@Override
        protected User doInBackground(Void... voids) {
            ImgurService imgurService = (ImgurService) RetrofitBuilder
		.getService(ImgurService.class, RetrofitBuilder.IMGUR_URL);
            UserService userService = (UserService) RetrofitBuilder
		.getService(UserService.class, RetrofitBuilder.BASE_URL);
            Call<Boolean> usernameCall = userService
		.checkUsername(template.getUsername());
            Response<Boolean> usernameResponse;
            try {
                usernameResponse = usernameCall.execute();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
        
            File file = null;
            try {

                file = new File(RegisterActivity.this.getCacheDir(), 
				"temp_profile");
                file.createNewFile();

//Convert bitmap to byte array

                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                croppedImage.compress(Bitmap.CompressFormat.PNG, 
			0 /*ignored for PNG*/, bos);
                byte[] bitmapdata = bos.toByteArray();

//write the bytes in file
                FileOutputStream fos = new FileOutputStream(file);
                fos.write(bitmapdata);
                fos.flush();
                fos.close();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
            ProgressRequestBody pBody = new ProgressRequestBody(file, 
		RegisterActivity.this);
            uploadImageCall = imgurService.uploadImage(pBody);
            Response<ImgurData> imgurResponse;
            try {
                imgurResponse = uploadImageCall.execute();
            } catch (IOException e) {
                return null;
            }
            template.setProfilePicture(imgurResponse.body()
			.getData().getId());
            Call<User> userCall = userService.register(template);
            Response<User> registeredUser;
            try {
                registeredUser = userCall.execute();
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
            return registeredUser.body();
        }
    }
	
	\end{lstlisting}
	
		\subsection{Logowanie do konta} \indent \par
		
		Logowanie do konta wykonywane jest przy pomocy adresu email oraz has³a podanego przy rejestracji. Obs³ug¹ widoku logowania zajmuje siê klasa \texttt{LoginActivity}. Po wprowadzeniu danych i naciœniêciu przycisku "`Log in"' walidowane s¹ pola danych, a nastêpnie przesy³ane na serwer z u¿yciem serwisu. Retrofit. W odpowiedzi na zapytanie przesy³any jest token dotêpu do API serwera, który zapamiêtywany jest w statycznym polu klasy \texttt{AppVariable}, aby móg³ zostaæ wykorzystany w kolejnych zapytaniach. Po poprawnym zalogowaniu aplikacji przechodzi do aktywnoœci \texttt{GpsActivity}.
		
\begin{lstlisting}[label={lst:login}, caption={Logowanie do konta}]
private void attemptLogin() {
    // Reset errors.
    usernameField.setError(null);
    passwordField.setError(null);

    // Store values at the time of the login attempt.
    String username = usernameField.getText().toString();
    String password = passwordField.getText().toString();

    boolean cancel = false;
    View focusView = null;

    // Check for a valid password, if the user entered one.
    if (TextUtils.isEmpty(password)) {
        passwordField.setError(getString(R.string.error_invalid_password));
        focusView = passwordField;
        cancel = true;
    }

    // Check for a valid email address.
    if (TextUtils.isEmpty(username)) {
        usernameField.setError(getString(R.string.error_field_required));
        focusView = usernameField;
        cancel = true;
    }

    if (cancel) {
        focusView.requestFocus();
    } else {
        showProgress(true);
        final AuthService authService = (AuthService) RetrofitBuilder
		.getService(AuthService.class, RetrofitBuilder.BASE_URL);
        Call<AuthenticationResponse> authCall;
        authCall = authService.authenticate(
		new AuthenticationRequest(username, password));
        authCall.enqueue(new Callback<AuthenticationResponse>() {
        @Override
        public void onResponse(Call<AuthenticationResponse> call, 
				Response<AuthenticationResponse> response) {

	if (response.code() == 200) {

		AppVariable.token = response.body().getToken();
		AppVariable.loggedUser = response.body().getUser();
		Toast.makeText(LoginActivity.this, 
		    "Login success", Toast.LENGTH_LONG).show();
		IntentHelper.startActivityIntent(LoginActivity.this,
		GpsActivity.class);
		finish();
	// }
	} else {
		AppVariable.token = "";
		AppVariable.loggedUser = null;
		passwordField.setError(getString(
			R.string.error_incorrect_password));
		passwordField.requestFocus();
		showProgress(false);
	}
}
}
		\end{lstlisting} 
		
		\subsection{Lokalizacja urz¹dzenia} \indent \par
		
		Po zalogowaniu aplikacja przechodzi do zapisu lokalizacji. Na ekranie wyœwietlony zostaje widok \texttt{activity\_gps.xml} obs³ugiwany przez \texttt{GpsActivity}. 
		
		Po utworzeniu widoku w metodzie \texttt{onCreate} pobierana jest instancja klasy \texttt{LocationManager} pozwalaj¹ca na nas³uchiwanie aktualizacji lokalizacyjnych telefonu. Przed rozpoczêciem aktualizacji nale¿y sprawdziæ czy modu³ GPS zosta³ w³¹czony w ustawieniach oraz czy aplikacji ma uprawnienia dostêpu. Je¿eli wymagane jest w³¹czenie którejœ z tych opcji w aplikacji pokazane zostanie stosowne okno dialogowe. Implementacja opisanego procesu zaprezentowana zosta³a na poni¿szym listingu.
		
\begin{lstlisting}[label={lst:gps}, caption={Sprawdzenie wymagañ u¿ycia modu³u GPS}]
public class GpsActivity extends AppCompatActivity 
		implements LocationListener {

android.location.Location lastKnown;

%%@BindView(%%R.id.settings%%)%%
Button settingsButton;

%%@BindView(%%R.id.status_text%%)%%
TextView statusText;

$$@Override
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_gps);
		ButterKnife.bind(this);
		AppVariable.locationManager = (LocationManager) 
			getSystemService(Context.LOCATION_SERVICE);
		AppVariable.locationListener = this;
		getLocation();
}

private void getLocation() {
	//TODO zmieniæ UI odpowiednio do wykonywanej czêœci


	boolean gpsPermission = checkPermissions();
	if (!gpsPermission) {
			Log.d(getClass().getSimpleName(), 
				"No GPS permissions!");
			requestPemissions();
			return;
	}
	boolean gpsEnabled = checkSettings();
	if (!gpsEnabled) {
			Log.d(getClass().getSimpleName(),
				"GPS not enabled!");
			buildAlertMessageNoGps();
			return;
	}
	//  subscribeForLocation(25f, this);
	getLocationUpdates();
}

private void requestPemissions() {
	Log.d(getClass().getSimpleName(), "Requesting permissions...");
	statusText.setText("Requesting permissions...");
	if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
		requestPermissions(new String[]{
		Manifest.permission.ACCESS_FINE_LOCATION,
		Manifest.permission.ACCESS_COARSE_LOCATION},
		IntentHelper.PERMISSION_GPS);
	}

	Log.d(getClass().getSimpleName(), "Done.");

}

private boolean checkSettings() {
	statusText.setText("Checking settings...");
	Log.d(getClass().getSimpleName(), "Checking settings...");
	return AppVariable.locationManager
	.isProviderEnabled(LocationManager.GPS_PROVIDER);
}

private boolean checkPermissions() {
	statusText.setText("Checking permissions...");
	Log.d(getClass().getSimpleName(), "Checking permissions...");
	
	return ActivityCompat.checkSelfPermission(this,
	Manifest.permission.ACCESS_FINE_LOCATION) == 
	PackageManager.PERMISSION_GRANTED &&
	ActivityCompat.checkSelfPermission(this, 
	Manifest.permission.ACCESS_COARSE_LOCATION) ==
	PackageManager.PERMISSION_GRANTED;
}

private void buildAlertMessageNoGps() {
	Log.d(getClass().getSimpleName(), "Showing GPS settings alert...");
	statusText.setText("Enable GPS to continue.");

	final AlertDialog.Builder builder = new AlertDialog.Builder(this);
	builder.setMessage("Your GPS seems to be disabled, 
				do you want to enable it?")
	  .setCancelable(false)
	  .setPositiveButton("Yes", new DialogInterface.OnClickListener() {
	  public void onClick(final DialogInterface dialog, final int id) {
		startActivityForResult(new Intent(
		android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS),
		IntentHelper.GPS_SETTINGS);
			}
		})
[...]
	});
	final AlertDialog alert = builder.create();
	alert.show();
}
\end{lstlisting} 



Jeœli modu³ GPS jest gotowy do u¿ycia, mo¿liwe jest rozpoczêcie nas³uchiwania. Android dostarcza dwóch metod lokalizacyjnych, za pomoc¹ GPS oraz na podstawie nadajników GSM. W aplikacji wykorzystywana jest g³ównie ta druga ze wzglêdu na szybsze aktualizacje, jednak uatywnione zostaj¹ obie. Przed wykonaniem dowolnej operacji korzystaj¹cej z obiekty \texttt{LocationManager}, konieczne jest wykonanie sprawdzenia uprawnieñ, w sposób pokazany metodzie \texttt{checkPermissions} na listingu \ref{lst:gps}.

\begin{lstlisting}[label={lst:gps2}, caption={Rozpoczêcie aktuazliacji GPS}]
public void getLocationUpdates() {
	statusText.setText("Waiting on GPS fix...");

  [...] // sprawdzenie uprawnieñ
	
	AppVariable.locationManager.requestLocationUpdates(
		LocationManager.NETWORK_PROVIDER, 0, 0, this);
	AppVariable.locationManager.requestLocationUpdates(
		LocationManager.GPS_PROVIDER, 0, 0, this);
}

\end{lstlisting} 

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{rys05/gps.png}%
\caption{Ekran zapisu lokalizacji - implementacja}%
\label{fig:gps_impl}%
\end{figure}	
		
		Aktualizacje lokalizacji otrzymywane s¹ przed zaimplementowany interfejs \texttt{LocationListener}. W trakcie oczekiwania na ekranie wyœwietlany jest stosowny komunikat, co pokazano na rysunku \ref{fig:gps_impl}. Je¿eli po aktualizacji dok³adnoœæ pozycji osi¹gnie wymagany poziom, wykonywany jest zapis do bazy z u¿yciem serwisu Retrofit, a lokalizacja zapamiêtywana jest w klasie \texttt{AppVariable}, aby przyspieszyæ jej pobieranie w kolejnych zapytaniach. Po wykonaniu zapisu wywo³ywana jest aktywnoœæ \texttt{TargetActivity}.
		
		
\begin{lstlisting}[label={lst:gps3}, caption={Obs³uga aktualizacji i zapis do bazy}]
private void saveLoginLocation() {
	Log.d("location", "Saving location");
	LocationService service = (LocationService) RetrofitBuilder
		.getService(LocationService.class, RetrofitBuilder.BASE_URL);
	Location loc = LocationHelper.map(lastKnown, Locations.LOGIN);
	Call<Void> saveCall = service.save(loc, AppVariable.token);
	saveCall.enqueue(new Callback<Void>() {
		$$@Override
		public void onResponse(Call<Void> call, 
				Response<Void> response) {
			if (response.code() == 200) {
				goToTargets();
			}
		}
	}

$$@Override
public void onLocationChanged(android.location.Location location) {
	if (location.getAccuracy() < Params.LOCATION_ACCURACY) {
		AppVariable.lastKnownLocation = new Location(
			location.getLatitude(), location.getLongitude());
		AppVariable.lastKnownLocationDate = new Date();
		lastKnown = location;
		if (!AppVariable.loginLocationSaved) {
			saveLoginLocation();
			AppVariable.loginLocationSaved = true;
		}
	}
}
\end{lstlisting} 


		\subsection{Lista zleceñ} \indent \par \label{lista_zlecen}
		
Organizacja widoki listy zleceñ jest inna od pozosta³ych aktywnoœci w aplikacji. Aby umo¿liwiæ podzia³ na dwie zak³adki zastosowane zosta³y komponenty \texttt{TabLayout} oraz \texttt{ViewPager} pozwalaj¹ce na zmianê widoku przeci¹gniêciem w poziomie po ekranie. Zawartoœæ poszczególnych widoków przeniesiona zosta³a do fragmentów. W przeciwieñstwie do aktywnoœci, fragemnty nie mog¹ wystêpowaæ samodzielnie w aplikacji, musz¹ byæ czêœci¹ jakiejœ aktywnoœci. Mo¿liwe jest jednak posiadanie wielu fragmentów jednoczeœnie w ramach jednego widoku.

Zasób widoków, jakie mog¹ zostaæ wyœwietlone na kartach definiuje siê w adapterze komponentu \texttt{ViewPager}. Zastosowan¹ klasê adaptera przedstawia listing \ref{lst:adapter}. Zdefiniowane zosta³y dwie karty o tytu³ach "`Private"' oraz "`Public"'.

		
\begin{lstlisting}[label={lst:adapter}, caption={Adapter fragmentów widoku zleceñ}]
public class TargetPageAdapter extends FragmentPagerAdapter {

    final int PAGE_COUNT = 2;
    private String tabTitles[] = new String[]{"Private", "Public"};
    private Context context;

    public TargetPageAdapter(FragmentManager fm, Context context) {
        super(fm);
        this.context = context;
    }

    $$@Override
    public int getCount() {
        return PAGE_COUNT;
    }

    $$@Override
    public Fragment getItem(int position) {
        return TargetsPageFragment.newInstance(position, position != 0);
    }
   $$ @Override
    public CharSequence getPageTitle(int position) {
        // Generate title based on item position
        return tabTitles[position];
    }
}

\end{lstlisting}

Fragmenty umieszczane na kartach sk³adaj¹ siê z komponentu \texttt{RecyclerView} wyœwietlaj¹cego listê zleceñ zawartego w widoku \texttt{SwipeRefreshLayout}. Widok ten pozwala na wykonanie wybranej akcji gestem poci¹gniêcia w dó³.

Lista \texttt{RecyclerView} korzysta z kontenerów nazywanych \texttt{ViewHolder} do wyœwietlania elementów. Konieczne jest zdefiniowanie pliku interfejsu okreœlaj¹cego wygl¹d elementu, a nastêpnie stworzenie zmiennych w klasie ViewHolder, które zostan¹ póŸniej wykorzystane ustawienia wyœwietlanych danych, i powi¹zanie ich z widokiem. W implementowanej liœcie pojedynczy element sk³ada siê ze zdjêcia, kilku elementów tekstowych oraz kolorowego paska statusu.

\begin{lstlisting}[label={lst:view_holder}, caption={Adapter fragmentów widoku zleceñ}]
protected static class ViewHolder extends RecyclerView.ViewHolder {

	%%@BindView(%%R.id.name%%)%%
	protected TextView name;

	%%@BindView(%%R.id.profile_image%%)%%
	ImageView profileImage;

	%%@BindView(%%R.id.text_distance%%)%%
	TextView distance;

	%%@BindView(%%R.id.text_time_left%%)%%
	TextView timeLeft;

	%%@BindView(%%R.id.status_view%%)%%
	View statusBarView;

	public ViewHolder(View view) {
		super(view);
		ButterKnife.bind(this, view);
	}
}
\end{lstlisting}

Listy \texttt{RecyclerView} podobnie jak \texttt{ViewPager} korzystaj¹ z adaptera do zarz¹dzania wyœwietlanymi danymi. Ze wzglêdu na to, ¿e proces jego implementacji mo¿e byæ skomplikowany, stworzone zosta³y liczne biblioteki maj¹ce na celu uproszczenie tego procesu. Biblioteka wykorzystana w tym projekcie to FastAdapter stworzona przez u¿ytkownika mikepenz serwisu GitHub, rozpowszechniana na licencji Apache 2.0. W tej implementacji wymagane jest jedynie stworzenie klasy modelu danych rozszerzaj¹cej dostarczon¹ w bibliotece klasê \texttt{AbstractItem}. 

W klasie nale¿y okreœliæ wykorzystywany plik interfejsu oraz przekazaæ dane do wyœwietlenia na dostarczonym obiekcie \texttt{ViewHolder} w metodzie \texttt{onBindViewHolder}. 



\begin{lstlisting}[label={lst:target_item}, caption={Adapter fragmentów widoku zleceñ}]
public class TargetItem extends AbstractItem<TargetItem, 
			TargetItem.ViewHolder> {
	Target target;
	Context context;
	//The unique ID for this type of item
	CountDownTimer timer;

	public TargetItem withTarget(Target target) {
		this.target = target;
		return this;
	}

	public TargetItem withContext(Context context) {
		this.context = context;
		return this;
	}

	$$@Override
	public int getType() {
		return R.id.target_list_item;
	}

	//The layout to be used for this type of item
	$$@Override
	public int getLayoutRes() {
		return R.layout.list_element;
	}

	public Target getTarget() {
		return target;
	}

	public void stopTimer() {
		Log.d("timer","stopTimer");
		if (timer != null)
			timer.cancel();
	}

//The logic to bind your data to the view
$$@Override
public void bindView(final ViewHolder viewHolder) {
    //call super so the selection is already handled for you
    super.bindView(viewHolder);

    viewHolder.name.setText(target.getHunted().getFirstName() + " " +
    target.getHunted().getLastName() + ", " +
    DateUtils.getAgeFromBirthDate(target.getHunted().getDateOfBirth()));
    ImageLoader imageLoader = ImageLoader.getInstance();
    imageLoader.displayImage(ImgurHelper.compileUrl(
        target.getHunted().getProfilePicture()), viewHolder.profileImage);
    viewHolder.distance.setText(String.valueOf(
                          LocationHelper.distance(target)));
    switch (target.getStatus()) {
        case Targets.ACTIVE:
            timer = new CountDownTimer(
                DateUtils.timeLeftOnTargetFromCreatedDateAsSeconds(
								                         target.getCreated()), 1000) {
                public void onTick(long millisUntilFinished) {
                    viewHolder.timeLeft.setText(
                        DateUtils.timeLeftOnTargetFromCreatedDate(
                             target.getCreated()));
                }};
            timer.start();
            viewHolder.statusBarView.setBackgroundColor(
                ContextCompat.getColor(context, R.color.target_yellow));
            break;
        case Targets.FAILED:
            viewHolder.timeLeft.setText(Targets.FAILED);
            viewHolder.statusBarView.setBackgroundColor(
                ContextCompat.getColor(context, R.color.target_red));
            if (timer != null) timer.cancel();
             break;
        case Targets.COMPLETED:
            viewHolder.timeLeft.setText(Targets.COMPLETED);
            viewHolder.statusBarView.setBackgroundColor(
                ContextCompat.getColor(context, R.color.target_green));
            if (timer != null) timer.cancel();
            break;
    }
}
\end{lstlisting}

Do tworzonego obiektu \texttt{TargetItem} przekazywany jest równie¿ pobrany z bazy danych obiekt \texttt{Target} zawieraj¹cy dane do wyœwietlenia. W metodzie \texttt{onBindViewHolder} ustawiane jest wyœwietlane zdjêcie, oraz w zale¿noœci od statusu tekst oraz kolor bocznego paska elementu. Je¿eli zlecenie pozostaje aktywne uruchamiane jest odliczanie, które co sekundê aktualizuje czas pozosta³y jego wykonanie. 

\

Pobieranie danych o zleceniach realizowane jest w klasie \texttt{TargetsPageFragment}. Metod¹ odpowiedzialn¹ za t¹ operacjê jest \texttt{refresh}. Na pocz¹tku zatrzymywane s¹ wszystkie zegary jakie mog¹ znajdowaæ siê na istniej¹cych elementach listy, a nastêpnie listy s¹ czyszczone. Przy u¿yciu Retrofit wykoywane jest zapytanie do serwera, a po otrzymaniu wyników, dla ka¿dego rekordu tworzony jest obiekt opisanej wczeœniej klasy \texttt{TargetItem}. Stworzone obiekty s¹ dodawane do adaptera w celu wyœwietlenia.


\begin{lstlisting}[label={lst:target_refresh}, caption={Metoda odœwie¿ania listy zleceñ}]
private void refresh() {
for (TargetItem t : recyclerItems) {
	t.stopTimer();
}
    recyclerItems.clear();
    fastAdapter.clear();
    targetCall = targetService.getTargetsForUser(
                 AppVariable.loggedUser.getId(), AppVariable.token);
    targetCall.enqueue(new Callback<List<Target>>() {
        @Override
        public void onResponse(Call<List<Target>> call,
				Response<List<Target>> response) {
            if (response.code() == 200) {
                List<Target> targets = response.body();
                Collections.sort(targets);
                List<TargetItem> items = new ArrayList<>();
                for (Target t : targets) {
                    if(t.isPublicTarget() == isPublic)
                         items.add(new TargetItem()
                          .withTarget(t)
                          .withContext(getActivity()));
                }
                refreshLayout.setRefreshing(false);
                recyclerItems.addAll(items);
                fastAdapter.add(items);
                fastAdapter.notifyDataSetChanged();
            }
        }
     );
}
\end{lstlisting}

Aby umo¿liwiæ odœwie¿anie listy z wykorzystaniem widoku \texttt{SwipeRefreshLayout} wymagane jest dodanie s³uchacza \texttt{OnRefreshLayout}. Po klikniêciu elementu listy powinna zostaæ uruchomiona aktywnoœæ szczegó³ów zlecenia. Przy u¿yciu biblioteki FastAdapter mo¿liwe jest dodanie s³uchacza \texttt{OnClickListener} do ka¿dego z elementów listy. Operacje te wykoywane s¹ w metodzie \texttt{onCreateView}.

\begin{lstlisting}[label={lst:listeners_target}, caption={Konfiguracja s³uchaczy klasy \texttt{TargetsPageFragment}}]
$$@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
 Bundle savedInstanceState) {

    View view = inflater.inflate(R.layout.content_targets_recycler,
		container, false);
    ButterKnife.bind(this, view);
    fastAdapter = new FastItemAdapter();
    recyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));
    recyclerView.setAdapter(fastAdapter);
    fastAdapter.withSelectable(true);
    fastAdapter.withOnClickListener(new FastAdapter
			.OnClickListener<TargetItem>() {
        $$@Override
        public boolean onClick(View v, IAdapter<TargetItem> adapter, 
                         TargetItem item, int position)    {
            openDetails(item.getTarget());
            return true;
        }
    });
    refreshLayout.setOnRefreshListener(
        new SwipeRefreshLayout.OnRefreshListener() {
            $$@Override
            public void onRefresh() {
                refresh();
            }
        });
    refresh();
    return view;
}
		
\end{lstlisting}

W metodzie \texttt{openDetais} dane modelu z wybranego elementu listy przekazywane s¹ przez klasê \texttt{Bundle} do aktywnoœci \texttt{DetailsActivity}.

\begin{lstlisting}[label={lst:open_details}, caption={Metoda uruchamiaj¹ca aktywnoœæ szczegó³ów zlecenia}]
private void openDetails(Target target) {
	Bundle bundle = new Bundle();
	bundle.putSerializable("target",target);
	IntentHelper.startActivityIntent(getActivity(),
		DetailsActivity.class,bundle);
}
	
\end{lstlisting}
		\subsection{Szczegó³y zlecenia}\indent \par
		
		Aktywnoœci¹ obs³uguj¹c¹ ekran szczegó³ów zlecenia jest \texttt{DetailsActivity}. Dane o wyœwietlanym zleceniu przekazywane s¹ w intencji przez klasê \texttt{Bundle}. Na widoku znajduje siê ten sam zestaw danych, co na elemencie listy opisanym w punkcie \ref{lista_zlecen}, zatem metoda inicjalizuj¹ca komponenty widoku jest zbli¿ona do tej przedstawionej na listingu \ref{lst:adapter}.	Zasadnicz¹ ró¿nic¹ jest sposób pobrania danych do inicjalizacji. Nie s¹ one przekazywane w konstruktorze, lecz musz¹ zostaæ pobrane z intencji. Widok inicjalizowany jest na podstawie otrzymanej klasy modelu \texttt{Target}.
		
\begin{lstlisting}[label={lst:init_view}, caption={Pobranie danych inicjalizuj¹cych z intencji}]	
private void initView(Target t) {
    target = t == null ? (Target) getIntent()
		.getSerializableExtra("target") : t;

    [...] // ustawienie wartoœci pól

}
\end{lstlisting}

Z poziomu widoku szczegó³ów zlecenia mo¿liwe jest wprowadzenie kodu potwierdzaj¹cego. U do³u ekranu znajduje siê pole tekstowe \texttt{codeField} oraz przycisk zatwierdzaj¹cy \texttt{sendButton}, co pokazano na rysunku \ref{fig:details_impl}. Metoda wysy³aj¹ca dane przypisana zosta³a za pomoc¹ adnotacji ButterKnife. Po naciœniêciu przycisku tworzone jest zapytanie z u¿yciem narzêdzia Retrofit, a nastêpnie przesy³ane na serwer. Po otrzymaniu odpowiedzi z serwera, widok jest ponownie inicjalizowany nowymi danymi. Je¿eli wprowadzony kod by³ niepoprawny, przycisk wysy³aj¹cy kod zostanie zablokowany na 10 sekund. Tworzony jest zegar, który odlicza czas i aktualizuje tekst wyœwietlany na przycisku co sekundê. 
	
		
\begin{lstlisting}[label={lst:init_view}, caption={Pobranie danych inicjalizuj¹cych z intencji}]	
%%@OnClick(%%R.id.send_button%%)%%
public void confirmTarget() {
    TargetService service = (TargetService) RetrofitBuilder
	.getService(TargetService.class, RetrofitBuilder.BASE_URL);
    Call<Target> confirmCall = service.confirm(target.getId(), 
	codeField.getText().toString().trim(), AppVariable.token);
    confirmCall.enqueue(new Callback<Target>() {
      $$@Override
      public void onResponse(Call<Target> call, Response<Target> response) {
            if (response.code() == 200 && 
		    response.body().getCompleted() != null) {
                target = response.body();
                initView(target);
            } else {
                sendButton.setEnabled(false);
                sendButton.setTextColor(ContextCompat.getColor(
		    DetailsActivity.this, R.color.placeholder_text));
                CountDownTimer timer = new CountDownTimer(
		    Params.WRONG_CODE_RETRY_TIME_SECONDS * 1000, 1000){
                $$@Override
                    public void onTick(long l) {
                      sendButton.setText(DateUtils.formatMillisAsYMDHMS(l));
                      sendButton.invalidate();
                    }

                $$@Override
                    public void onFinish() {
                        sendButton.setText(R.string.button_code_send);
                        sendButton.setEnabled(true); 
                        sendButton.setTextColor(ContextCompat.getColor(
			DetailsActivity.this, R.color.white));
                        sendButton.invalidate();
                    }
                 };
                 timer.start();
             }          
         }
    });
}

\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[draft=false,width=6cm]{rys05/details.png}%
\caption{Widok szczegó³ów zlecenia - implementacja}%
\label{fig:details_impl}%
\end{figure}


Na górnym pasku aplikacji znajduje siê przycisk z ikon¹ mapy. Po jego klikniêciu otwarta zostaje aktywnoœæ \texttt{MapActivity} wyœwietlaj¹ca znane lokalizacje gracza. Ponownie dane zlecenia przekazywane s¹ przez obiekt \texttt{Bundle}. Ze wzglêdu na to, ¿e przycisk ten nie nale¿y do klasy \texttt{Button}, lecz jest elementem menu kontekstowego, za jego obs³ugê odpowiedzialna jest metoda \texttt{onOptionsItemSelected}. 

\begin{lstlisting}[label={lst:map_options}, caption={Obs³uga wywo³ania aktywnoœci mapy}]	
$$@Override
public boolean onOptionsItemSelected(MenuItem menuItem) {
    if (menuItem.getItemId() == android.R.id.home) {
        finish();
    }
    if (menuItem.getItemId() == R.id.action_map) {
        Bundle bundle = new Bundle();
        bundle.putSerializable("target", target);
        IntentHelper.startActivityIntent(this, MapActivity.class, bundle);
    }
    return super.onOptionsItemSelected(menuItem);
}
\end{lstlisting}

		
		\subsection{Mapa znanych lokalizacji u¿ytkownika}\indent \par
		
Umieszczenie mapy Google wewn¹trz widoku odbywa siê poprzez dodanie do pliku interfejsu fragmentu z ustawionym parametrem \texttt{android:name="com.google.android.gms.maps.MapFragment"}. Pod zadany widok zostanie podpiêta instancja klasy \texttt{MapFragment}. Kontroler aktywnoœci musi implementowaæ interfejs \texttt{OnMapReadyCallback}. Po utworzeniu widoku mapa jest pobierana metod¹ \texttt{getMapAsync}. Nastepnie z serwera pobierane s¹ punkty lokalizacyjne za pomoc¹ interfejsu Retrofit.

\begin{lstlisting}[language=XML, label={lst:map_xml}, caption={Fragment pliku interfejsu aktywnoœci \texttt{MapActivity}}]	
<fragment xmlns:android="http://schemas.android.com/apk/res/android"
	xmlns:tools="http://schemas.android.com/tools"
	xmlns:map="http://schemas.android.com/apk/res-auto"
	android:layout_width="match_parent"
	android:layout_height="match_parent"
	android:id="@+id/map"
	tools:context="mafia.adamzimny.mafia.activity.MapActivity"
	android:name="com.google.android.gms.maps.SupportMapFragment"/>
		\end{lstlisting}


Narzêdzie Google Maps oferuje mo¿liwoœæ grupowania znaczników znajduj¹cych siê blisko siebie w celu zwiêkszenia przejrzystoœci mapy. Grupowanie wymaga utworzenia obiektu \texttt{ClusterManager}, którzy zarz¹dza wyœwietlanymi znacznikami. W przypadku wyœwietlania bez grupowania znaczniki dodawaæ mo¿na bezpoœrednio do obiektu mapy. Po pobraniu danych o lokalizacji znaczniki dodawane s¹ w jeden z opisanych wy¿ej sposobów zaleznie od ustawionych preferencji. Znacznikow przypisywane s¹ dodatkowe informacje \texttt{title} oraz \texttt{snippet} wyœwietlane po klikniêciu na znacznik. Dla lokalizacji zapisanych mniej ni¿ tydzieñ temu w tytule zamiast pe³nej daty wyœwietlony zostanie wzglêdny czas utworzenia. Na rysunku \ref{fig:map_4} przedstawiono efekt dodania znaczników dla przyk³adowych danych.

\begin{lstlisting}[label={lst:map_options}, caption={Obs³uga wywo³ania aktywnoœci mapy}]	

$$@Override
public void onMapReady(GoogleMap googleMap) {
		map = googleMap;
		setUpClusterer();
}

private void setUpClusterer() {
	mClusterManager = new ClusterManager<>(this, map);
	map.setOnCameraIdleListener(mClusterManager);
	map.setOnMarkerClickListener(mClusterManager);
	mClusterManager.setRenderer(new OwnRendring(
		getApplicationContext(), map, mClusterManager));
}


public void getHuntedLocations() {

    [...]   // Retrofit call

    for (Location l : list) {
      if (DateUtils.daysSince(l.getDate().getTime()) > 6) {
        if (AppVariable.useMarkerClusters) {
          mClusterManager.addItem(new MapMarker(l.getLatitude(),
            l.getLongitude(), DateUtils.date(l.getDate().getTime()),
             DateUtils.hour(l.getDate().getTime())));
        } else {
           map.addMarker(new MarkerOptions()
             .position(new LatLng(l.getLatitude(), l.getLongitude()))
             .title(DateUtils.date(l.getDate().getTime()))
             .snippet(DateUtils.hour(l.getDate().getTime())));
       }} else {
          if (AppVariable.useMarkerClusters) {
             mClusterManager.addItem(new MapMarker(l.getLatitude(),
               l.getLongitude(), android.text.format.DateUtils
               .getRelativeTimeSpanString(
           l.getDate().getTime()) + "",
             DateUtils.format(l.getDate().getTime())));
          } else {
             map.addMarker(new MarkerOptions()
             .position(new LatLng(l.getLatitude(), l.getLongitude()))
             .title(android.text.format.DateUtils.getRelativeTimeSpanString(
                l.getDate().getTime()) + "")
             .snippet( DateUtils.format(l.getDate().getTime())));
          }
       }
    }
}
\end{lstlisting}

		
		
\begin{figure}[H] 
\centering
\begin{subfigure}[b]{0.33\linewidth}
	\centering
	\includegraphics[draft=false,width=.8\linewidth]{rys05/map2.png} 
	\caption{Znaczniki lokalizacji} 
	\label{fig7:a} 
\end{subfigure}%% 
\begin{subfigure}[b]{0.33\linewidth}
	\centering
	\includegraphics[draft=false,width=.8\linewidth]{rys05/map1.png} 
	\caption{Grupa znaczników} 
	\label{fig7:b} 
\end{subfigure} 
\begin{subfigure}[b]{0.33\linewidth}
	\centering
	\includegraphics[draft=false,width=.8\linewidth]{rys05/map3.png} 
	\caption{Okno z danymi o znaczniku} 
	\label{fig7:c} 
\end{subfigure}%%
\caption{Mapa lokalizacji u¿ytkownika po dodaniu znaczników}
\label{fig:map_4} 
\end{figure}
		
		
		
		\subsection{Generowanie kodów potwierdzaj¹cych} \indent \par
		
Do aktywnoœci generowania kodu przejœæ mo¿na z bocznego panelu nawigacyjnego. Kontrolerem aktywnoœci jest klasa \texttt{CodeActivity}. Do generowania kodu wykorzystywany jest przycisk utworzony przy pomocy biblioteki HoldToLoadLayout. Podczas przytrzymania przycisku wyœwietlany jest pasek ³adowania. Biblioteka wymaga zaimplementowania metod wywo³ywanych po ukoñczeniu ³adowania. Po utworzeniu widoku, w metodzie \texttt{onCreateView} przypisywana jest instancja s³uchacza wyzwalaj¹cego zdarzenia po osi¹gniêciu stanu pe³nego i pustego paska ³adowania. Wygl¹d interfejsu podczas ³adowania przedstawiono na rysunku \ref{fig:code_layout}.

\begin{lstlisting}[label={lst:hold_layout}, caption={Obs³uga zdarzeñ przycisku wykorzystuj¹cego \texttt{HoldToLoadLayout}}]	
button.setFillListener(new HoldToLoadLayout.FillListener() {
	$$@Override
	public void onFull() {
		if (canSendRequests) {
			generateCode();
			codeField.setText(codeString);
			progressBar.setProgress(0);
			canSendRequests = false;
		}
		button.setStrokeColor(R.color.target_green);
		button.setDuration(750);
	}

	[...] // onEmpty(), onAngleChanged()
	
});
\end{lstlisting}


\begin{figure}[H]
\centering
\includegraphics[draft=false, width=6cm]{rys05/code.png}%
\caption{Widok generowania kodu podczas ³adowania przycisku}%
\label{fig:code_layout}%
\end{figure}



Po ukoñczeniu ³adowania przycisku wywo³ywana jest metoda \texttt{generateCode} tworz¹ca losowy ci¹g znaków i wykonuj¹ca zapis do bazy przez zapytanie http. Tworzony jest równie¿ zegar aktualizuj¹cy interfejs co sekundê w celu wizualizacji pozosta³ego czasu aktywnoœci kodu. Metoda \texttt{setDuration} pozwala zmieniæ czas potrzebny na wype³nienie ³adowania.


\begin{lstlisting}[label={lst:code_gen}, caption={Generowanie kodu}]	
private void generateCode() {
    codeString = nextString(Params.CODE_LENGTH);
    AppVariable.code = codeString;
    Log.d("code", "Code generated! " + codeString);
    if (timer != null) timer.cancel();
    timer = new CountDownTimer(TWO_MINUTES, 1000) {
        public void onTick(long millisUntilFinished) {
            AppVariable.codeTimeLeft = millisUntilFinished;
            time.setText(DateUtils.formatMillisAsYMDHMS(millisUntilFinished));
            progressBar.setProgressWithAnimation(
		millisUntilFinished * 100f / TWO_MINUTES, 2000);
        }

        public void onFinish() {
            codeField.setText("Code expired!");
            progressBar.setProgress(0);
            time.setText("0m 00s");
        }

    };
    timer.start();
		
    Location codeLocation = AppVariable.lastKnownLocation;
    codeLocation.setType(Locations.CODE);
    Code code = Code.Builder
        .create()
        .withCode(codeString)
        .withCreated(new Date())
        .withLocation(codeLocation)
        .withUser(AppVariable.loggedUser)
        .build();

    CodeService service = (CodeService) RetrofitBuilder
        .getService(CodeService.class, RetrofitBuilder.BASE_URL);
    Call<String> call = service.createNewCode(AppVariable.token, code);
    call.enqueue( [...] );
}

\end{lstlisting}

Do generowania kodów wykorzystana zosta³a metoda \texttt{nextString}, której parametrem jest d³ugoœæ ci¹gu znaków. Kody sk³adaj¹ siê z du¿ych liter i cyfr.

\begin{lstlisting}[label={lst:code_gen}, caption={Generowanie losowego ci¹gu znaków}]	

private final Random random = new Random();

public String nextString(int len) {
	StringBuilder tmp;

	tmp = new StringBuilder();
	for (char ch = '0'; ch <= '9'; ++ch)
	tmp.append(ch);
	for (char ch = 'A'; ch <= 'Z'; ++ch)
	tmp.append(ch);
	char[] symbols = tmp.toString().toCharArray();
	tmp.setLength(0);

	for (int i = 0; i < len; i++)
		tmp.append(symbols[random.nextInt(symbols.length)]);
	return tmp.toString();
}

\end{lstlisting}
